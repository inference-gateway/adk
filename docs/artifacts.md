# A2A Protocol Artifacts in the ADK

This document explains how to use artifacts in the A2A Agent Development Kit (ADK), including creating, managing, and accessing artifacts on both the server and client side.

## What are Artifacts?

Artifacts in the A2A protocol represent files, data structures, or other resources generated by agents during task execution. They provide a structured way to return rich content beyond simple text responses, including:

- **Text content**: Analysis results, reports, documentation
- **Files**: Generated documents, images, data files
- **Structured data**: JSON objects, analysis results, metadata
- **Multi-part content**: Combinations of the above

## Artifact Structure

Each artifact follows the A2A protocol specification:

```go
type Artifact struct {
    ArtifactID  string         // Required: Unique identifier
    Name        *string        // Optional: Human-readable name
    Description *string        // Optional: Description of the artifact
    Extensions  []string       // Optional: Protocol extension URIs
    Metadata    map[string]any // Optional: Extension-specific metadata
    Parts       []Part         // Required: Array of content parts
}
```

### Content Parts

Artifacts contain one or more parts of different types:

1. **TextPart**: Plain text content
2. **FilePart**: File data (bytes or URI reference)
3. **DataPart**: Structured JSON data

## Server-Side Usage

### Basic Artifact Creation

```go
import "github.com/inference-gateway/adk/server"

// Create artifact helper
artifactHelper := server.NewArtifactHelper()

// Create a text artifact
textArtifact := artifactHelper.CreateTextArtifact(
    "Analysis Report",                    // name
    "Detailed analysis of the request",   // description
    "This is the analysis content...",    // text content
)

// Add to task
artifactHelper.AddArtifactToTask(task, textArtifact)
```

### File Artifacts

```go
// Create file artifact from bytes
data := []byte("Hello, World!")
mimeType := artifactHelper.GetMimeTypeFromExtension("hello.txt")

fileArtifact := artifactHelper.CreateFileArtifactFromBytes(
    "Generated File",
    "A simple text file",
    "hello.txt",
    data,
    mimeType,
)

// Create file artifact from URI
uriArtifact := artifactHelper.CreateFileArtifactFromURI(
    "External Resource",
    "Link to documentation",
    "docs.html",
    "https://example.com/docs.html",
    stringPtr("text/html"),
)
```

### Data Artifacts

```go
// Create structured data artifact
analysisData := map[string]any{
    "summary": "Task completed successfully",
    "metrics": map[string]any{
        "processing_time": 1.5,
        "word_count":     150,
    },
    "results": []string{"item1", "item2", "item3"},
}

dataArtifact := artifactHelper.CreateDataArtifact(
    "Analysis Results",
    "Structured analysis data",
    analysisData,
)
```

### Multi-Part Artifacts

```go
// Combine different content types
parts := []types.Part{
    types.TextPart{
        Kind: "text",
        Text: "Summary of the analysis",
    },
    types.DataPart{
        Kind: "data",
        Data: map[string]any{
            "confidence": 0.95,
            "category": "positive",
        },
    },
}

multiArtifact := artifactHelper.CreateMultiPartArtifact(
    "Complete Analysis",
    "Analysis with both summary and data",
    parts,
)
```

### Custom Task Handler with Artifacts

```go
type MyTaskHandler struct {
    logger         *zap.Logger
    artifactHelper *server.ArtifactHelper
}

func (h *MyTaskHandler) HandleTask(ctx context.Context, task *types.Task, message *types.Message) (*types.Task, error) {
    // Process the task...

    // Create artifacts based on processing results
    resultArtifact := h.artifactHelper.CreateTextArtifact(
        "Processing Result",
        "Result of task processing",
        "Task completed with result: success",
    )

    h.artifactHelper.AddArtifactToTask(task, resultArtifact)

    // Mark task as completed
    task.Status.State = types.TaskStateCompleted

    return task, nil
}
```

### Streaming Artifacts

For real-time streaming scenarios, you can send artifact updates:

```go
// In a StreamableTaskHandler
func (h *MyStreamingHandler) HandleStreamingTask(ctx context.Context, task *types.Task, message *types.Message) (<-chan server.StreamEvent, error) {
    eventsChan := make(chan server.StreamEvent, 100)

    go func() {
        defer close(eventsChan)

        // Create artifact during processing
        artifact := h.artifactHelper.CreateTextArtifact(
            "Streaming Result",
            "Partial result from streaming",
            "Current progress: 50%",
        )

        // Send artifact update event
        artifactEvent := h.artifactHelper.CreateTaskArtifactUpdateEvent(
            task.ID,
            task.ContextID,
            artifact,
            boolPtr(false), // append
            boolPtr(false), // lastChunk
        )

        eventsChan <- &server.ArtifactUpdateStreamEvent{
            Event: artifactEvent,
        }

        // Continue processing...
    }()

    return eventsChan, nil
}
```

## Client-Side Usage

### Extracting Artifacts from Responses

```go
import "github.com/inference-gateway/adk/client"

// Create client with artifact helper
a2aClient := client.NewClient("http://localhost:8080")
artifactHelper := a2aClient.GetArtifactHelper()

// Send task and get response
response, err := a2aClient.SendTask(ctx, params)
if err != nil {
    return err
}

// Extract task from response
task, err := artifactHelper.ExtractTaskFromResponse(response)
if err != nil {
    return err
}

// Check if task has artifacts
if artifactHelper.HasArtifacts(task) {
    fmt.Printf("Task contains %d artifacts\n", artifactHelper.GetArtifactCount(task))
}
```

### Working with Different Artifact Types

```go
// Get artifacts by type
textArtifacts := artifactHelper.GetTextArtifacts(task)
fileArtifacts := artifactHelper.GetFileArtifacts(task)
dataArtifacts := artifactHelper.GetDataArtifacts(task)

// Extract text content
for _, artifact := range textArtifacts {
    texts := artifactHelper.ExtractTextFromArtifact(&artifact)
    for _, text := range texts {
        fmt.Println("Text content:", text)
    }
}

// Extract file data
for _, artifact := range fileArtifacts {
    files, err := artifactHelper.ExtractFileDataFromArtifact(&artifact)
    if err != nil {
        continue
    }

    for _, file := range files {
        if file.IsDataFile() {
            fmt.Printf("File: %s (%d bytes)\n", file.GetFileName(), len(file.Data))
            // Process file.Data
        } else if file.IsURIFile() {
            fmt.Printf("File URI: %s\n", *file.URI)
            // Fetch from URI if needed
        }
    }
}

// Extract structured data
for _, artifact := range dataArtifacts {
    dataList := artifactHelper.ExtractDataFromArtifact(&artifact)
    for _, data := range dataList {
        // Process structured data
        fmt.Printf("Data: %+v\n", data)
    }
}
```

### Searching and Filtering Artifacts

```go
// Find specific artifact by ID
artifact, found := artifactHelper.GetArtifactByID(task, "artifact-id-123")
if found {
    fmt.Printf("Found artifact: %s\n", *artifact.Name)
}

// Filter by name pattern
analysisArtifacts := artifactHelper.FilterArtifactsByName(task, "analysis")
fmt.Printf("Found %d analysis artifacts\n", len(analysisArtifacts))

// Get artifact summary by type
summary := artifactHelper.GetArtifactSummary(task)
for partType, count := range summary {
    fmt.Printf("%s parts: %d\n", partType, count)
}
```

### Handling Streaming Artifact Updates

```go
// Handle streaming responses
eventChan := make(chan any, 100)

err := a2aClient.SendTaskStreaming(ctx, params, eventChan)
if err != nil {
    return err
}

for event := range eventChan {
    // Check for artifact updates
    if artifactEvent, isArtifact := artifactHelper.ExtractArtifactUpdateFromStreamEvent(event); isArtifact {
        fmt.Printf("Received artifact update: %s\n", artifactEvent.Artifact.ArtifactID)

        // Process the artifact
        if artifactEvent.Artifact.Name != nil {
            fmt.Printf("Artifact name: %s\n", *artifactEvent.Artifact.Name)
        }

        // Check if this is the last chunk
        if artifactEvent.LastChunk != nil && *artifactEvent.LastChunk {
            fmt.Println("This is the final artifact update")
        }
    }
}
```

## Examples

### Complete Server Example

See `examples/server/cmd/artifacts/main.go` for a complete server implementation that demonstrates:

- Creating various types of artifacts
- Adding artifacts to tasks during processing
- Implementing a custom task handler with artifact support
- Proper artifact validation and error handling

### Complete Client Example

See `examples/client/cmd/artifacts/main.go` for a complete client implementation that demonstrates:

- Sending tasks and retrieving responses with artifacts
- Extracting different types of content from artifacts
- Searching and filtering artifacts
- Handling file data and structured data

## Best Practices

### Server-Side

1. **Validate Artifacts**: Use `artifactHelper.ValidateArtifact()` to ensure artifacts conform to the specification
2. **Use Appropriate MIME Types**: Use `artifactHelper.GetMimeTypeFromExtension()` for file artifacts
3. **Limit Artifact Size**: Be mindful of artifact size, especially for embedded files
4. **Meaningful Names**: Provide descriptive names and descriptions for artifacts
5. **Structured Data**: Use consistent data structures for DataPart content

### Client-Side

1. **Check for Artifacts**: Always check `HasArtifacts()` before attempting extraction
2. **Handle Errors**: File extraction and data parsing can fail, handle errors gracefully
3. **Memory Management**: Large file artifacts can consume significant memory
4. **URI Validation**: Validate URIs before attempting to fetch external resources
5. **Type Checking**: Use appropriate type checking when working with extracted data

## Error Handling

Common error scenarios and how to handle them:

```go
// Server-side validation
if err := artifactHelper.ValidateArtifact(artifact); err != nil {
    return fmt.Errorf("invalid artifact: %w", err)
}

// Client-side extraction
task, err := artifactHelper.ExtractTaskFromResponse(response)
if err != nil {
    return fmt.Errorf("failed to extract task: %w", err)
}

files, err := artifactHelper.ExtractFileDataFromArtifact(&artifact)
if err != nil {
    // Handle file extraction error
    log.Printf("Failed to extract files: %v", err)
    continue
}
```

## Integration with A2A Protocol

Artifacts are fully integrated with the A2A protocol:

- **`tasks/get`**: Returns tasks with their associated artifacts
- **`message/stream`**: Can receive `TaskArtifactUpdateEvent` for real-time updates
- **Task Lifecycle**: Artifacts persist with tasks throughout their lifecycle
- **Protocol Compliance**: All artifact structures conform to the A2A specification

The ADK handles all the low-level protocol details, allowing you to focus on creating and consuming artifacts in your applications.
