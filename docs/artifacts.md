# A2A Protocol Artifacts in the ADK

This document explains how to use artifacts in the A2A Agent Development Kit (ADK), including creating, managing, and accessing artifacts on both the server and client side.

## Table of Contents

- [What are Artifacts?](#what-are-artifacts)
- [Artifact Structure](#artifact-structure)
  - [Content Parts](#content-parts)
- [Server-Side Usage](#server-side-usage)
  - [Basic Artifact Creation](#basic-artifact-creation)
  - [File Artifacts](#file-artifacts)
  - [Data Artifacts](#data-artifacts)
  - [Multi-Part Artifacts](#multi-part-artifacts)
  - [Custom Task Handler with Artifacts](#custom-task-handler-with-artifacts)
  - [Streaming Artifacts](#streaming-artifacts)
- [Client-Side Usage](#client-side-usage)
  - [Extracting Artifacts from Responses](#extracting-artifacts-from-responses)
  - [Working with Different Artifact Types](#working-with-different-artifact-types)
  - [Searching and Filtering Artifacts](#searching-and-filtering-artifacts)
  - [Downloading Artifact Files](#downloading-artifact-files)
    - [Download Configuration Options](#download-configuration-options)
    - [Download Individual Artifacts](#download-individual-artifacts)
    - [Download Single File](#download-single-file)
    - [File Organization](#file-organization)
    - [Handling Both URI and Byte-Based Files](#handling-both-uri-and-byte-based-files)
    - [Error Handling](#error-handling)
  - [Handling Streaming Artifact Updates](#handling-streaming-artifact-updates)
- [Examples](#examples)
  - [Complete Server Example](#complete-server-example)
  - [Complete Client Example](#complete-client-example)
- [Best Practices](#best-practices)
  - [Server-Side](#server-side)
  - [Client-Side](#client-side)
- [Error Handling](#error-handling-1)
- [Integration with A2A Protocol](#integration-with-a2a-protocol)

## What are Artifacts?

Artifacts in the A2A protocol represent files, data structures, or other resources generated by agents during task execution. They provide a structured way to return rich content beyond simple text responses, including:

- **Text content**: Analysis results, reports, documentation
- **Files**: Generated documents, images, data files
- **Structured data**: JSON objects, analysis results, metadata
- **Multi-part content**: Combinations of the above

## Artifact Structure

Each artifact follows the A2A protocol specification:

```go
type Artifact struct {
    ArtifactID  string         // Required: Unique identifier
    Name        *string        // Optional: Human-readable name
    Description *string        // Optional: Description of the artifact
    Extensions  []string       // Optional: Protocol extension URIs
    Metadata    map[string]any // Optional: Extension-specific metadata
    Parts       []Part         // Required: Array of content parts
}
```

### Content Parts

Artifacts contain one or more parts of different types:

1. **TextPart**: Plain text content
2. **FilePart**: File data (bytes or URI reference)
3. **DataPart**: Structured JSON data

## Server-Side Usage

### Basic Artifact Creation

```go
import "github.com/inference-gateway/adk/server"

// Create artifact helper
artifactHelper := server.NewArtifactHelper()

// Create a text artifact
textArtifact := artifactHelper.CreateTextArtifact(
    "Analysis Report",                    // name
    "Detailed analysis of the request",   // description
    "This is the analysis content...",    // text content
)

// Add to task
artifactHelper.AddArtifactToTask(task, textArtifact)
```

### File Artifacts

```go
// Create file artifact from bytes
data := []byte("Hello, World!")
mimeType := artifactHelper.GetMimeTypeFromExtension("hello.txt")

fileArtifact := artifactHelper.CreateFileArtifactFromBytes(
    "Generated File",
    "A simple text file",
    "hello.txt",
    data,
    mimeType,
)

// Create file artifact from URI
uriArtifact := artifactHelper.CreateFileArtifactFromURI(
    "External Resource",
    "Link to documentation",
    "docs.html",
    "https://example.com/docs.html",
    stringPtr("text/html"),
)
```

### Data Artifacts

```go
// Create structured data artifact
analysisData := map[string]any{
    "summary": "Task completed successfully",
    "metrics": map[string]any{
        "processing_time": 1.5,
        "word_count":     150,
    },
    "results": []string{"item1", "item2", "item3"},
}

dataArtifact := artifactHelper.CreateDataArtifact(
    "Analysis Results",
    "Structured analysis data",
    analysisData,
)
```

### Multi-Part Artifacts

```go
// Combine different content types
parts := []types.Part{
    types.TextPart{
        Kind: "text",
        Text: "Summary of the analysis",
    },
    types.DataPart{
        Kind: "data",
        Data: map[string]any{
            "confidence": 0.95,
            "category": "positive",
        },
    },
}

multiArtifact := artifactHelper.CreateMultiPartArtifact(
    "Complete Analysis",
    "Analysis with both summary and data",
    parts,
)
```

### Autonomous Artifact Creation with CreateArtifact Tool

The ADK includes a built-in `create_artifact` tool that allows LLMs to autonomously create artifacts without requiring custom task handler implementation. This tool is disabled by default and must be enabled through configuration.

#### Enabling the CreateArtifact Tool

```bash
# Enable via environment variable
export CAPABILITIES_CREATE_ARTIFACT=true
```

```go
// Enable via configuration
capabilities := &config.CapabilitiesConfig{
    CreateArtifact: true,
}

// Create agent with capabilities-enabled toolbox
agent := server.NewAgentBuilder(logger).
    WithConfig(agentConfig).
    WithDefaultToolBox(capabilities).
    Build()
```

#### How the CreateArtifact Tool Works

When enabled, the LLM can autonomously use the `create_artifact` tool during task processing:

**Tool Parameters:**
- `content` (required): The text content to save as an artifact file
- `type` (required): Must be "url" - indicates the artifact will be available as a downloadable URL
- `name` (optional): Name for the artifact (auto-generated if not provided)
- `filename` (optional): Filename with extension (auto-detected from content if not provided)

**Auto File-Type Detection:**
The tool automatically detects file types based on content:
- JSON objects/arrays → `.json`
- HTML documents → `.html`
- XML documents → `.xml`
- CSS stylesheets → `.css`
- JavaScript code → `.js`
- Markdown → `.md`
- CSV data → `.csv`
- Plain text → `.txt` (fallback)

#### Example LLM Usage

When the tool is enabled, an LLM can create artifacts like this:

```json
{
  "tool_calls": [
    {
      "function": {
        "name": "create_artifact",
        "arguments": {
          "content": "{\"results\": [\"item1\", \"item2\"], \"summary\": \"Analysis complete\"}",
          "type": "url",
          "name": "Analysis Results"
        }
      }
    }
  ]
}
```

This will automatically:
1. Detect the content as JSON and use filename `content.json`
2. Create an artifact with the provided content
3. Store it on the filesystem via the artifact storage provider
4. Add it to the current task
5. Return a success response with the artifact ID and download URL

#### Tool Response Format

The tool returns a JSON response:

```json
{
  "success": true,
  "message": "Artifact 'Analysis Results' created successfully",
  "artifact_id": "uuid-generated-id",
  "url": "http://localhost:8081/artifacts/uuid-generated-id/content.json",
  "filename": "content.json"
}
```

#### Integration Requirements

For the CreateArtifact tool to work properly, you need:

1. **Artifact Storage**: Configure artifact storage (filesystem, MinIO, S3, etc.)
2. **Context Setup**: The tool requires `taskManager` and `artifactHelper` in the execution context
3. **Task ID**: The current task ID must be available in the context

This is automatically handled when using the standard ADK server setup with artifact storage enabled.

### Custom Task Handler with Artifacts

```go
type MyTaskHandler struct {
    logger         *zap.Logger
    artifactHelper *server.ArtifactHelper
}

func (h *MyTaskHandler) HandleTask(ctx context.Context, task *types.Task, message *types.Message) (*types.Task, error) {
    // Process the task...

    // Create artifacts based on processing results
    resultArtifact := h.artifactHelper.CreateTextArtifact(
        "Processing Result",
        "Result of task processing",
        "Task completed with result: success",
    )

    h.artifactHelper.AddArtifactToTask(task, resultArtifact)

    // Mark task as completed
    task.Status.State = types.TaskStateCompleted

    return task, nil
}
```

### Streaming Artifacts

For real-time streaming scenarios, you can send artifact updates:

```go
// In a StreamableTaskHandler
func (h *MyStreamingHandler) HandleStreamingTask(ctx context.Context, task *types.Task, message *types.Message) (<-chan server.StreamEvent, error) {
    eventsChan := make(chan server.StreamEvent, 100)

    go func() {
        defer close(eventsChan)

        // Create artifact during processing
        artifact := h.artifactHelper.CreateTextArtifact(
            "Streaming Result",
            "Partial result from streaming",
            "Current progress: 50%",
        )

        // Send artifact update event
        artifactEvent := h.artifactHelper.CreateTaskArtifactUpdateEvent(
            task.ID,
            task.ContextID,
            artifact,
            boolPtr(false), // append
            boolPtr(false), // lastChunk
        )

        eventsChan <- &server.ArtifactUpdateStreamEvent{
            Event: artifactEvent,
        }

        // Continue processing...
    }()

    return eventsChan, nil
}
```

## Client-Side Usage

### Extracting Artifacts from Responses

```go
import "github.com/inference-gateway/adk/client"

// Create client with artifact helper
a2aClient := client.NewClient("http://localhost:8080")
artifactHelper := a2aClient.GetArtifactHelper()

// Send task and get response
response, err := a2aClient.SendTask(ctx, params)
if err != nil {
    return err
}

// Extract task from response
task, err := artifactHelper.ExtractTaskFromResponse(response)
if err != nil {
    return err
}

// Check if task has artifacts
if artifactHelper.HasArtifacts(task) {
    fmt.Printf("Task contains %d artifacts\n", artifactHelper.GetArtifactCount(task))
}
```

### Working with Different Artifact Types

```go
// Get artifacts by type
textArtifacts := artifactHelper.GetTextArtifacts(task)
fileArtifacts := artifactHelper.GetFileArtifacts(task)
dataArtifacts := artifactHelper.GetDataArtifacts(task)

// Extract text content
for _, artifact := range textArtifacts {
    texts := artifactHelper.ExtractTextFromArtifact(&artifact)
    for _, text := range texts {
        fmt.Println("Text content:", text)
    }
}

// Extract file data
for _, artifact := range fileArtifacts {
    files, err := artifactHelper.ExtractFileDataFromArtifact(&artifact)
    if err != nil {
        continue
    }

    for _, file := range files {
        if file.IsDataFile() {
            fmt.Printf("File: %s (%d bytes)\n", file.GetFileName(), len(file.Data))
            // Process file.Data
        } else if file.IsURIFile() {
            fmt.Printf("File URI: %s\n", *file.URI)
            // Fetch from URI if needed
        }
    }
}

// Extract structured data
for _, artifact := range dataArtifacts {
    dataList := artifactHelper.ExtractDataFromArtifact(&artifact)
    for _, data := range dataList {
        // Process structured data
        fmt.Printf("Data: %+v\n", data)
    }
}
```

### Searching and Filtering Artifacts

```go
// Find specific artifact by ID
artifact, found := artifactHelper.GetArtifactByID(task, "artifact-id-123")
if found {
    fmt.Printf("Found artifact: %s\n", *artifact.Name)
}

// Filter by name pattern
analysisArtifacts := artifactHelper.FilterArtifactsByName(task, "analysis")
fmt.Printf("Found %d analysis artifacts\n", len(analysisArtifacts))

// Get artifact summary by type
summary := artifactHelper.GetArtifactSummary(task)
for partType, count := range summary {
    fmt.Printf("%s parts: %d\n", partType, count)
}
```

### Downloading Artifact Files

The ADK provides built-in utilities to download artifact files to disk:

```go
// Basic download - downloads all artifacts from a task
helper := a2aClient.GetArtifactHelper()

downloadConfig := &client.DownloadConfig{
    OutputDir:            "downloads",      // Directory to save files
    OverwriteExisting:    true,            // Allow overwriting existing files
    OrganizeByArtifactID: true,            // Create subdirectories by artifact ID (default: true)
}

results, err := helper.DownloadAllArtifacts(ctx, task, downloadConfig)
if err != nil {
    return fmt.Errorf("download failed: %w", err)
}

// Process download results
for _, result := range results {
    if result.Error != nil {
        fmt.Printf("❌ Failed to download %s: %v\n", result.FileName, result.Error)
    } else {
        fmt.Printf("✅ Downloaded %s (%d bytes) to %s\n",
            result.FileName, result.BytesWritten, result.FilePath)
    }
}
```

#### Download Configuration Options

```go
type DownloadConfig struct {
    // OutputDir: Base directory for downloads (default: current directory)
    OutputDir string

    // HTTPClient: Custom HTTP client for URI downloads (default: http.DefaultClient)
    HTTPClient *http.Client

    // OverwriteExisting: Allow overwriting existing files (default: false)
    OverwriteExisting bool

    // OrganizeByArtifactID: Create subdirectories by artifact ID (default: true)
    // When enabled, files are saved to: OutputDir/{artifact-id}/filename
    // This prevents collisions when multiple artifacts have the same filename
    OrganizeByArtifactID bool
}
```

#### Download Individual Artifacts

```go
// Download files from a specific artifact
artifact, found := helper.GetArtifactByID(task, "artifact-123")
if found {
    results, err := helper.DownloadArtifact(ctx, artifact, downloadConfig)
    if err != nil {
        return err
    }

    for _, result := range results {
        fmt.Printf("Downloaded: %s\n", result.FilePath)
    }
}
```

#### Download Single File

```go
// Download a specific file
files, err := helper.ExtractFileDataFromArtifact(artifact)
if err != nil {
    return err
}

for _, file := range files {
    result, err := helper.DownloadFileData(ctx, file, downloadConfig)
    if err != nil {
        fmt.Printf("Download failed: %v\n", err)
        continue
    }

    fmt.Printf("Downloaded %s to %s\n", result.FileName, result.FilePath)
}
```

#### File Organization

When `OrganizeByArtifactID` is enabled (default), files are organized as:

```
downloads/
├── artifact-id-1/
│   ├── report.pdf
│   └── data.json
├── artifact-id-2/
│   ├── report.pdf      # No collision with artifact-id-1/report.pdf
│   └── analysis.txt
└── artifact-id-3/
    └── summary.md
```

When disabled, all files are saved to the same directory:

```
downloads/
├── report.pdf          # May be overwritten by other artifacts
├── data.json
├── analysis.txt
└── summary.md
```

#### Handling Both URI and Byte-Based Files

The download utility handles both file types automatically:

```go
// Works with both FileWithBytes and FileWithUri
files, _ := helper.ExtractFileDataFromArtifact(artifact)

for _, file := range files {
    if file.IsURIFile() {
        fmt.Printf("Downloading from URI: %s\n", *file.URI)
    } else if file.IsDataFile() {
        fmt.Printf("Saving embedded file: %s (%d bytes)\n",
            file.GetFileName(), len(file.Data))
    }

    // Download handles both cases
    result, err := helper.DownloadFileData(ctx, file, downloadConfig)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        continue
    }
}
```

#### Error Handling

```go
results, err := helper.DownloadAllArtifacts(ctx, task, downloadConfig)
if err != nil {
    // Fatal error during download process
    return fmt.Errorf("download failed: %w", err)
}

// Check individual file results
for _, result := range results {
    if result.Error != nil {
        // Handle individual file errors
        log.Printf("Failed to download %s: %v", result.FileName, result.Error)

        // Common errors:
        // - Network errors for URI downloads
        // - Permission errors for file creation
        // - Disk space errors
        // - File already exists (when OverwriteExisting is false)
    } else {
        // File downloaded successfully
        log.Printf("Downloaded %s: %d bytes written",
            result.FileName, result.BytesWritten)
    }
}
```

### Handling Streaming Artifact Updates

```go
// Handle streaming responses
eventChan := make(chan any, 100)

err := a2aClient.SendTaskStreaming(ctx, params, eventChan)
if err != nil {
    return err
}

for event := range eventChan {
    // Check for artifact updates
    if artifactEvent, isArtifact := artifactHelper.ExtractArtifactUpdateFromStreamEvent(event); isArtifact {
        fmt.Printf("Received artifact update: %s\n", artifactEvent.Artifact.ArtifactID)

        // Process the artifact
        if artifactEvent.Artifact.Name != nil {
            fmt.Printf("Artifact name: %s\n", *artifactEvent.Artifact.Name)
        }

        // Check if this is the last chunk
        if artifactEvent.LastChunk != nil && *artifactEvent.LastChunk {
            fmt.Println("This is the final artifact update")
        }
    }
}
```

## Examples

### Complete Server Example

See `examples/server/cmd/artifacts/main.go` for a complete server implementation that demonstrates:

- Creating various types of artifacts
- Adding artifacts to tasks during processing
- Implementing a custom task handler with artifact support
- Proper artifact validation and error handling

### Complete Client Example

See `examples/client/cmd/artifacts/main.go` for a complete client implementation that demonstrates:

- Sending tasks and retrieving responses with artifacts
- Extracting different types of content from artifacts
- Searching and filtering artifacts
- Handling file data and structured data

## Best Practices

### Server-Side

1. **Validate Artifacts**: Use `artifactHelper.ValidateArtifact()` to ensure artifacts conform to the specification
2. **Use Appropriate MIME Types**: Use `artifactHelper.GetMimeTypeFromExtension()` for file artifacts
3. **Limit Artifact Size**: Be mindful of artifact size, especially for embedded files
4. **Meaningful Names**: Provide descriptive names and descriptions for artifacts
5. **Structured Data**: Use consistent data structures for DataPart content

### Client-Side

1. **Check for Artifacts**: Always check `HasArtifacts()` before attempting extraction
2. **Handle Errors**: File extraction and data parsing can fail, handle errors gracefully
3. **Memory Management**: Large file artifacts can consume significant memory
4. **URI Validation**: Validate URIs before attempting to fetch external resources
5. **Type Checking**: Use appropriate type checking when working with extracted data
6. **File Organization**: Use `OrganizeByArtifactID: true` (default) to prevent filename collisions
7. **Download Results**: Check individual `DownloadResult.Error` fields for per-file error handling
8. **Custom HTTP Client**: Provide a custom `HTTPClient` with timeouts and retry logic for URI downloads

## Error Handling

Common error scenarios and how to handle them:

```go
// Server-side validation
if err := artifactHelper.ValidateArtifact(artifact); err != nil {
    return fmt.Errorf("invalid artifact: %w", err)
}

// Client-side extraction
task, err := artifactHelper.ExtractTaskFromResponse(response)
if err != nil {
    return fmt.Errorf("failed to extract task: %w", err)
}

files, err := artifactHelper.ExtractFileDataFromArtifact(&artifact)
if err != nil {
    // Handle file extraction error
    log.Printf("Failed to extract files: %v", err)
    continue
}
```

## Integration with A2A Protocol

Artifacts are fully integrated with the A2A protocol:

- **`tasks/get`**: Returns tasks with their associated artifacts
- **`message/stream`**: Can receive `TaskArtifactUpdateEvent` for real-time updates
- **Task Lifecycle**: Artifacts persist with tasks throughout their lifecycle
- **Protocol Compliance**: All artifact structures conform to the A2A specification

The ADK handles all the low-level protocol details, allowing you to focus on creating and consuming artifacts in your applications.
