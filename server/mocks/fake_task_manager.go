// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"
	"time"

	"github.com/inference-gateway/adk/server"
	"github.com/inference-gateway/adk/server/config"
	"github.com/inference-gateway/adk/types"
)

type FakeTaskManager struct {
	CancelTaskStub        func(string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupCompletedTasksStub        func()
	cleanupCompletedTasksMutex       sync.RWMutex
	cleanupCompletedTasksArgsForCall []struct {
	}
	CreateTaskStub        func(string, types.TaskState, *types.Message) *types.Task
	createTaskMutex       sync.RWMutex
	createTaskArgsForCall []struct {
		arg1 string
		arg2 types.TaskState
		arg3 *types.Message
	}
	createTaskReturns struct {
		result1 *types.Task
	}
	createTaskReturnsOnCall map[int]struct {
		result1 *types.Task
	}
	CreateTaskWithHistoryStub        func(string, types.TaskState, *types.Message, []types.Message) *types.Task
	createTaskWithHistoryMutex       sync.RWMutex
	createTaskWithHistoryArgsForCall []struct {
		arg1 string
		arg2 types.TaskState
		arg3 *types.Message
		arg4 []types.Message
	}
	createTaskWithHistoryReturns struct {
		result1 *types.Task
	}
	createTaskWithHistoryReturnsOnCall map[int]struct {
		result1 *types.Task
	}
	DeleteTaskPushNotificationConfigStub        func(types.DeleteTaskPushNotificationConfigParams) error
	deleteTaskPushNotificationConfigMutex       sync.RWMutex
	deleteTaskPushNotificationConfigArgsForCall []struct {
		arg1 types.DeleteTaskPushNotificationConfigParams
	}
	deleteTaskPushNotificationConfigReturns struct {
		result1 error
	}
	deleteTaskPushNotificationConfigReturnsOnCall map[int]struct {
		result1 error
	}
	GetConversationHistoryStub        func(string) []types.Message
	getConversationHistoryMutex       sync.RWMutex
	getConversationHistoryArgsForCall []struct {
		arg1 string
	}
	getConversationHistoryReturns struct {
		result1 []types.Message
	}
	getConversationHistoryReturnsOnCall map[int]struct {
		result1 []types.Message
	}
	GetTaskStub        func(string) (*types.Task, bool)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 string
	}
	getTaskReturns struct {
		result1 *types.Task
		result2 bool
	}
	getTaskReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 bool
	}
	GetTaskPushNotificationConfigStub        func(types.GetTaskPushNotificationConfigParams) (*types.TaskPushNotificationConfig, error)
	getTaskPushNotificationConfigMutex       sync.RWMutex
	getTaskPushNotificationConfigArgsForCall []struct {
		arg1 types.GetTaskPushNotificationConfigParams
	}
	getTaskPushNotificationConfigReturns struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}
	getTaskPushNotificationConfigReturnsOnCall map[int]struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}
	IsTaskPausedStub        func(string) (bool, error)
	isTaskPausedMutex       sync.RWMutex
	isTaskPausedArgsForCall []struct {
		arg1 string
	}
	isTaskPausedReturns struct {
		result1 bool
		result2 error
	}
	isTaskPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListTaskPushNotificationConfigsStub        func(types.ListTaskPushNotificationConfigParams) ([]types.TaskPushNotificationConfig, error)
	listTaskPushNotificationConfigsMutex       sync.RWMutex
	listTaskPushNotificationConfigsArgsForCall []struct {
		arg1 types.ListTaskPushNotificationConfigParams
	}
	listTaskPushNotificationConfigsReturns struct {
		result1 []types.TaskPushNotificationConfig
		result2 error
	}
	listTaskPushNotificationConfigsReturnsOnCall map[int]struct {
		result1 []types.TaskPushNotificationConfig
		result2 error
	}
	ListTasksStub        func(types.TaskListParams) (*types.TaskList, error)
	listTasksMutex       sync.RWMutex
	listTasksArgsForCall []struct {
		arg1 types.TaskListParams
	}
	listTasksReturns struct {
		result1 *types.TaskList
		result2 error
	}
	listTasksReturnsOnCall map[int]struct {
		result1 *types.TaskList
		result2 error
	}
	PauseTaskForInputStub        func(string, *types.Message) error
	pauseTaskForInputMutex       sync.RWMutex
	pauseTaskForInputArgsForCall []struct {
		arg1 string
		arg2 *types.Message
	}
	pauseTaskForInputReturns struct {
		result1 error
	}
	pauseTaskForInputReturnsOnCall map[int]struct {
		result1 error
	}
	PollTaskStatusStub        func(string, time.Duration, time.Duration) (*types.Task, error)
	pollTaskStatusMutex       sync.RWMutex
	pollTaskStatusArgsForCall []struct {
		arg1 string
		arg2 time.Duration
		arg3 time.Duration
	}
	pollTaskStatusReturns struct {
		result1 *types.Task
		result2 error
	}
	pollTaskStatusReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 error
	}
	ResumeTaskWithInputStub        func(string, *types.Message) error
	resumeTaskWithInputMutex       sync.RWMutex
	resumeTaskWithInputArgsForCall []struct {
		arg1 string
		arg2 *types.Message
	}
	resumeTaskWithInputReturns struct {
		result1 error
	}
	resumeTaskWithInputReturnsOnCall map[int]struct {
		result1 error
	}
	SetRetentionConfigStub        func(config.TaskRetentionConfig)
	setRetentionConfigMutex       sync.RWMutex
	setRetentionConfigArgsForCall []struct {
		arg1 config.TaskRetentionConfig
	}
	SetTaskPushNotificationConfigStub        func(types.TaskPushNotificationConfig) (*types.TaskPushNotificationConfig, error)
	setTaskPushNotificationConfigMutex       sync.RWMutex
	setTaskPushNotificationConfigArgsForCall []struct {
		arg1 types.TaskPushNotificationConfig
	}
	setTaskPushNotificationConfigReturns struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}
	setTaskPushNotificationConfigReturnsOnCall map[int]struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}
	StopCleanupStub        func()
	stopCleanupMutex       sync.RWMutex
	stopCleanupArgsForCall []struct {
	}
	UpdateConversationHistoryStub        func(string, []types.Message)
	updateConversationHistoryMutex       sync.RWMutex
	updateConversationHistoryArgsForCall []struct {
		arg1 string
		arg2 []types.Message
	}
	UpdateErrorStub        func(string, *types.Message) error
	updateErrorMutex       sync.RWMutex
	updateErrorArgsForCall []struct {
		arg1 string
		arg2 *types.Message
	}
	updateErrorReturns struct {
		result1 error
	}
	updateErrorReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStateStub        func(string, types.TaskState) error
	updateStateMutex       sync.RWMutex
	updateStateArgsForCall []struct {
		arg1 string
		arg2 types.TaskState
	}
	updateStateReturns struct {
		result1 error
	}
	updateStateReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateTaskStub        func(*types.Task) error
	updateTaskMutex       sync.RWMutex
	updateTaskArgsForCall []struct {
		arg1 *types.Task
	}
	updateTaskReturns struct {
		result1 error
	}
	updateTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTaskManager) CancelTask(arg1 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CancelTaskStub
	fakeReturns := fake.cancelTaskReturns
	fake.recordInvocation("CancelTask", []interface{}{arg1})
	fake.cancelTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeTaskManager) CancelTaskCalls(stub func(string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeTaskManager) CancelTaskArgsForCall(i int) string {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) CleanupCompletedTasks() {
	fake.cleanupCompletedTasksMutex.Lock()
	fake.cleanupCompletedTasksArgsForCall = append(fake.cleanupCompletedTasksArgsForCall, struct {
	}{})
	stub := fake.CleanupCompletedTasksStub
	fake.recordInvocation("CleanupCompletedTasks", []interface{}{})
	fake.cleanupCompletedTasksMutex.Unlock()
	if stub != nil {
		fake.CleanupCompletedTasksStub()
	}
}

func (fake *FakeTaskManager) CleanupCompletedTasksCallCount() int {
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	return len(fake.cleanupCompletedTasksArgsForCall)
}

func (fake *FakeTaskManager) CleanupCompletedTasksCalls(stub func()) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = stub
}

func (fake *FakeTaskManager) CreateTask(arg1 string, arg2 types.TaskState, arg3 *types.Message) *types.Task {
	fake.createTaskMutex.Lock()
	ret, specificReturn := fake.createTaskReturnsOnCall[len(fake.createTaskArgsForCall)]
	fake.createTaskArgsForCall = append(fake.createTaskArgsForCall, struct {
		arg1 string
		arg2 types.TaskState
		arg3 *types.Message
	}{arg1, arg2, arg3})
	stub := fake.CreateTaskStub
	fakeReturns := fake.createTaskReturns
	fake.recordInvocation("CreateTask", []interface{}{arg1, arg2, arg3})
	fake.createTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) CreateTaskCallCount() int {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	return len(fake.createTaskArgsForCall)
}

func (fake *FakeTaskManager) CreateTaskCalls(stub func(string, types.TaskState, *types.Message) *types.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = stub
}

func (fake *FakeTaskManager) CreateTaskArgsForCall(i int) (string, types.TaskState, *types.Message) {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	argsForCall := fake.createTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTaskManager) CreateTaskReturns(result1 *types.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	fake.createTaskReturns = struct {
		result1 *types.Task
	}{result1}
}

func (fake *FakeTaskManager) CreateTaskReturnsOnCall(i int, result1 *types.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	if fake.createTaskReturnsOnCall == nil {
		fake.createTaskReturnsOnCall = make(map[int]struct {
			result1 *types.Task
		})
	}
	fake.createTaskReturnsOnCall[i] = struct {
		result1 *types.Task
	}{result1}
}

func (fake *FakeTaskManager) CreateTaskWithHistory(arg1 string, arg2 types.TaskState, arg3 *types.Message, arg4 []types.Message) *types.Task {
	var arg4Copy []types.Message
	if arg4 != nil {
		arg4Copy = make([]types.Message, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.createTaskWithHistoryMutex.Lock()
	ret, specificReturn := fake.createTaskWithHistoryReturnsOnCall[len(fake.createTaskWithHistoryArgsForCall)]
	fake.createTaskWithHistoryArgsForCall = append(fake.createTaskWithHistoryArgsForCall, struct {
		arg1 string
		arg2 types.TaskState
		arg3 *types.Message
		arg4 []types.Message
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.CreateTaskWithHistoryStub
	fakeReturns := fake.createTaskWithHistoryReturns
	fake.recordInvocation("CreateTaskWithHistory", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.createTaskWithHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) CreateTaskWithHistoryCallCount() int {
	fake.createTaskWithHistoryMutex.RLock()
	defer fake.createTaskWithHistoryMutex.RUnlock()
	return len(fake.createTaskWithHistoryArgsForCall)
}

func (fake *FakeTaskManager) CreateTaskWithHistoryCalls(stub func(string, types.TaskState, *types.Message, []types.Message) *types.Task) {
	fake.createTaskWithHistoryMutex.Lock()
	defer fake.createTaskWithHistoryMutex.Unlock()
	fake.CreateTaskWithHistoryStub = stub
}

func (fake *FakeTaskManager) CreateTaskWithHistoryArgsForCall(i int) (string, types.TaskState, *types.Message, []types.Message) {
	fake.createTaskWithHistoryMutex.RLock()
	defer fake.createTaskWithHistoryMutex.RUnlock()
	argsForCall := fake.createTaskWithHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTaskManager) CreateTaskWithHistoryReturns(result1 *types.Task) {
	fake.createTaskWithHistoryMutex.Lock()
	defer fake.createTaskWithHistoryMutex.Unlock()
	fake.CreateTaskWithHistoryStub = nil
	fake.createTaskWithHistoryReturns = struct {
		result1 *types.Task
	}{result1}
}

func (fake *FakeTaskManager) CreateTaskWithHistoryReturnsOnCall(i int, result1 *types.Task) {
	fake.createTaskWithHistoryMutex.Lock()
	defer fake.createTaskWithHistoryMutex.Unlock()
	fake.CreateTaskWithHistoryStub = nil
	if fake.createTaskWithHistoryReturnsOnCall == nil {
		fake.createTaskWithHistoryReturnsOnCall = make(map[int]struct {
			result1 *types.Task
		})
	}
	fake.createTaskWithHistoryReturnsOnCall[i] = struct {
		result1 *types.Task
	}{result1}
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfig(arg1 types.DeleteTaskPushNotificationConfigParams) error {
	fake.deleteTaskPushNotificationConfigMutex.Lock()
	ret, specificReturn := fake.deleteTaskPushNotificationConfigReturnsOnCall[len(fake.deleteTaskPushNotificationConfigArgsForCall)]
	fake.deleteTaskPushNotificationConfigArgsForCall = append(fake.deleteTaskPushNotificationConfigArgsForCall, struct {
		arg1 types.DeleteTaskPushNotificationConfigParams
	}{arg1})
	stub := fake.DeleteTaskPushNotificationConfigStub
	fakeReturns := fake.deleteTaskPushNotificationConfigReturns
	fake.recordInvocation("DeleteTaskPushNotificationConfig", []interface{}{arg1})
	fake.deleteTaskPushNotificationConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfigCallCount() int {
	fake.deleteTaskPushNotificationConfigMutex.RLock()
	defer fake.deleteTaskPushNotificationConfigMutex.RUnlock()
	return len(fake.deleteTaskPushNotificationConfigArgsForCall)
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfigCalls(stub func(types.DeleteTaskPushNotificationConfigParams) error) {
	fake.deleteTaskPushNotificationConfigMutex.Lock()
	defer fake.deleteTaskPushNotificationConfigMutex.Unlock()
	fake.DeleteTaskPushNotificationConfigStub = stub
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfigArgsForCall(i int) types.DeleteTaskPushNotificationConfigParams {
	fake.deleteTaskPushNotificationConfigMutex.RLock()
	defer fake.deleteTaskPushNotificationConfigMutex.RUnlock()
	argsForCall := fake.deleteTaskPushNotificationConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfigReturns(result1 error) {
	fake.deleteTaskPushNotificationConfigMutex.Lock()
	defer fake.deleteTaskPushNotificationConfigMutex.Unlock()
	fake.DeleteTaskPushNotificationConfigStub = nil
	fake.deleteTaskPushNotificationConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) DeleteTaskPushNotificationConfigReturnsOnCall(i int, result1 error) {
	fake.deleteTaskPushNotificationConfigMutex.Lock()
	defer fake.deleteTaskPushNotificationConfigMutex.Unlock()
	fake.DeleteTaskPushNotificationConfigStub = nil
	if fake.deleteTaskPushNotificationConfigReturnsOnCall == nil {
		fake.deleteTaskPushNotificationConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskPushNotificationConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) GetConversationHistory(arg1 string) []types.Message {
	fake.getConversationHistoryMutex.Lock()
	ret, specificReturn := fake.getConversationHistoryReturnsOnCall[len(fake.getConversationHistoryArgsForCall)]
	fake.getConversationHistoryArgsForCall = append(fake.getConversationHistoryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetConversationHistoryStub
	fakeReturns := fake.getConversationHistoryReturns
	fake.recordInvocation("GetConversationHistory", []interface{}{arg1})
	fake.getConversationHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) GetConversationHistoryCallCount() int {
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	return len(fake.getConversationHistoryArgsForCall)
}

func (fake *FakeTaskManager) GetConversationHistoryCalls(stub func(string) []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = stub
}

func (fake *FakeTaskManager) GetConversationHistoryArgsForCall(i int) string {
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	argsForCall := fake.getConversationHistoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) GetConversationHistoryReturns(result1 []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = nil
	fake.getConversationHistoryReturns = struct {
		result1 []types.Message
	}{result1}
}

func (fake *FakeTaskManager) GetConversationHistoryReturnsOnCall(i int, result1 []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = nil
	if fake.getConversationHistoryReturnsOnCall == nil {
		fake.getConversationHistoryReturnsOnCall = make(map[int]struct {
			result1 []types.Message
		})
	}
	fake.getConversationHistoryReturnsOnCall[i] = struct {
		result1 []types.Message
	}{result1}
}

func (fake *FakeTaskManager) GetTask(arg1 string) (*types.Task, bool) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeTaskManager) GetTaskCalls(stub func(string) (*types.Task, bool)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeTaskManager) GetTaskArgsForCall(i int) string {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) GetTaskReturns(result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeTaskManager) GetTaskReturnsOnCall(i int, result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 bool
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfig(arg1 types.GetTaskPushNotificationConfigParams) (*types.TaskPushNotificationConfig, error) {
	fake.getTaskPushNotificationConfigMutex.Lock()
	ret, specificReturn := fake.getTaskPushNotificationConfigReturnsOnCall[len(fake.getTaskPushNotificationConfigArgsForCall)]
	fake.getTaskPushNotificationConfigArgsForCall = append(fake.getTaskPushNotificationConfigArgsForCall, struct {
		arg1 types.GetTaskPushNotificationConfigParams
	}{arg1})
	stub := fake.GetTaskPushNotificationConfigStub
	fakeReturns := fake.getTaskPushNotificationConfigReturns
	fake.recordInvocation("GetTaskPushNotificationConfig", []interface{}{arg1})
	fake.getTaskPushNotificationConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfigCallCount() int {
	fake.getTaskPushNotificationConfigMutex.RLock()
	defer fake.getTaskPushNotificationConfigMutex.RUnlock()
	return len(fake.getTaskPushNotificationConfigArgsForCall)
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfigCalls(stub func(types.GetTaskPushNotificationConfigParams) (*types.TaskPushNotificationConfig, error)) {
	fake.getTaskPushNotificationConfigMutex.Lock()
	defer fake.getTaskPushNotificationConfigMutex.Unlock()
	fake.GetTaskPushNotificationConfigStub = stub
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfigArgsForCall(i int) types.GetTaskPushNotificationConfigParams {
	fake.getTaskPushNotificationConfigMutex.RLock()
	defer fake.getTaskPushNotificationConfigMutex.RUnlock()
	argsForCall := fake.getTaskPushNotificationConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfigReturns(result1 *types.TaskPushNotificationConfig, result2 error) {
	fake.getTaskPushNotificationConfigMutex.Lock()
	defer fake.getTaskPushNotificationConfigMutex.Unlock()
	fake.GetTaskPushNotificationConfigStub = nil
	fake.getTaskPushNotificationConfigReturns = struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) GetTaskPushNotificationConfigReturnsOnCall(i int, result1 *types.TaskPushNotificationConfig, result2 error) {
	fake.getTaskPushNotificationConfigMutex.Lock()
	defer fake.getTaskPushNotificationConfigMutex.Unlock()
	fake.GetTaskPushNotificationConfigStub = nil
	if fake.getTaskPushNotificationConfigReturnsOnCall == nil {
		fake.getTaskPushNotificationConfigReturnsOnCall = make(map[int]struct {
			result1 *types.TaskPushNotificationConfig
			result2 error
		})
	}
	fake.getTaskPushNotificationConfigReturnsOnCall[i] = struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) IsTaskPaused(arg1 string) (bool, error) {
	fake.isTaskPausedMutex.Lock()
	ret, specificReturn := fake.isTaskPausedReturnsOnCall[len(fake.isTaskPausedArgsForCall)]
	fake.isTaskPausedArgsForCall = append(fake.isTaskPausedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsTaskPausedStub
	fakeReturns := fake.isTaskPausedReturns
	fake.recordInvocation("IsTaskPaused", []interface{}{arg1})
	fake.isTaskPausedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) IsTaskPausedCallCount() int {
	fake.isTaskPausedMutex.RLock()
	defer fake.isTaskPausedMutex.RUnlock()
	return len(fake.isTaskPausedArgsForCall)
}

func (fake *FakeTaskManager) IsTaskPausedCalls(stub func(string) (bool, error)) {
	fake.isTaskPausedMutex.Lock()
	defer fake.isTaskPausedMutex.Unlock()
	fake.IsTaskPausedStub = stub
}

func (fake *FakeTaskManager) IsTaskPausedArgsForCall(i int) string {
	fake.isTaskPausedMutex.RLock()
	defer fake.isTaskPausedMutex.RUnlock()
	argsForCall := fake.isTaskPausedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) IsTaskPausedReturns(result1 bool, result2 error) {
	fake.isTaskPausedMutex.Lock()
	defer fake.isTaskPausedMutex.Unlock()
	fake.IsTaskPausedStub = nil
	fake.isTaskPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) IsTaskPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isTaskPausedMutex.Lock()
	defer fake.isTaskPausedMutex.Unlock()
	fake.IsTaskPausedStub = nil
	if fake.isTaskPausedReturnsOnCall == nil {
		fake.isTaskPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isTaskPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigs(arg1 types.ListTaskPushNotificationConfigParams) ([]types.TaskPushNotificationConfig, error) {
	fake.listTaskPushNotificationConfigsMutex.Lock()
	ret, specificReturn := fake.listTaskPushNotificationConfigsReturnsOnCall[len(fake.listTaskPushNotificationConfigsArgsForCall)]
	fake.listTaskPushNotificationConfigsArgsForCall = append(fake.listTaskPushNotificationConfigsArgsForCall, struct {
		arg1 types.ListTaskPushNotificationConfigParams
	}{arg1})
	stub := fake.ListTaskPushNotificationConfigsStub
	fakeReturns := fake.listTaskPushNotificationConfigsReturns
	fake.recordInvocation("ListTaskPushNotificationConfigs", []interface{}{arg1})
	fake.listTaskPushNotificationConfigsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigsCallCount() int {
	fake.listTaskPushNotificationConfigsMutex.RLock()
	defer fake.listTaskPushNotificationConfigsMutex.RUnlock()
	return len(fake.listTaskPushNotificationConfigsArgsForCall)
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigsCalls(stub func(types.ListTaskPushNotificationConfigParams) ([]types.TaskPushNotificationConfig, error)) {
	fake.listTaskPushNotificationConfigsMutex.Lock()
	defer fake.listTaskPushNotificationConfigsMutex.Unlock()
	fake.ListTaskPushNotificationConfigsStub = stub
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigsArgsForCall(i int) types.ListTaskPushNotificationConfigParams {
	fake.listTaskPushNotificationConfigsMutex.RLock()
	defer fake.listTaskPushNotificationConfigsMutex.RUnlock()
	argsForCall := fake.listTaskPushNotificationConfigsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigsReturns(result1 []types.TaskPushNotificationConfig, result2 error) {
	fake.listTaskPushNotificationConfigsMutex.Lock()
	defer fake.listTaskPushNotificationConfigsMutex.Unlock()
	fake.ListTaskPushNotificationConfigsStub = nil
	fake.listTaskPushNotificationConfigsReturns = struct {
		result1 []types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) ListTaskPushNotificationConfigsReturnsOnCall(i int, result1 []types.TaskPushNotificationConfig, result2 error) {
	fake.listTaskPushNotificationConfigsMutex.Lock()
	defer fake.listTaskPushNotificationConfigsMutex.Unlock()
	fake.ListTaskPushNotificationConfigsStub = nil
	if fake.listTaskPushNotificationConfigsReturnsOnCall == nil {
		fake.listTaskPushNotificationConfigsReturnsOnCall = make(map[int]struct {
			result1 []types.TaskPushNotificationConfig
			result2 error
		})
	}
	fake.listTaskPushNotificationConfigsReturnsOnCall[i] = struct {
		result1 []types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) ListTasks(arg1 types.TaskListParams) (*types.TaskList, error) {
	fake.listTasksMutex.Lock()
	ret, specificReturn := fake.listTasksReturnsOnCall[len(fake.listTasksArgsForCall)]
	fake.listTasksArgsForCall = append(fake.listTasksArgsForCall, struct {
		arg1 types.TaskListParams
	}{arg1})
	stub := fake.ListTasksStub
	fakeReturns := fake.listTasksReturns
	fake.recordInvocation("ListTasks", []interface{}{arg1})
	fake.listTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) ListTasksCallCount() int {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	return len(fake.listTasksArgsForCall)
}

func (fake *FakeTaskManager) ListTasksCalls(stub func(types.TaskListParams) (*types.TaskList, error)) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = stub
}

func (fake *FakeTaskManager) ListTasksArgsForCall(i int) types.TaskListParams {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	argsForCall := fake.listTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) ListTasksReturns(result1 *types.TaskList, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	fake.listTasksReturns = struct {
		result1 *types.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) ListTasksReturnsOnCall(i int, result1 *types.TaskList, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	if fake.listTasksReturnsOnCall == nil {
		fake.listTasksReturnsOnCall = make(map[int]struct {
			result1 *types.TaskList
			result2 error
		})
	}
	fake.listTasksReturnsOnCall[i] = struct {
		result1 *types.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) PauseTaskForInput(arg1 string, arg2 *types.Message) error {
	fake.pauseTaskForInputMutex.Lock()
	ret, specificReturn := fake.pauseTaskForInputReturnsOnCall[len(fake.pauseTaskForInputArgsForCall)]
	fake.pauseTaskForInputArgsForCall = append(fake.pauseTaskForInputArgsForCall, struct {
		arg1 string
		arg2 *types.Message
	}{arg1, arg2})
	stub := fake.PauseTaskForInputStub
	fakeReturns := fake.pauseTaskForInputReturns
	fake.recordInvocation("PauseTaskForInput", []interface{}{arg1, arg2})
	fake.pauseTaskForInputMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) PauseTaskForInputCallCount() int {
	fake.pauseTaskForInputMutex.RLock()
	defer fake.pauseTaskForInputMutex.RUnlock()
	return len(fake.pauseTaskForInputArgsForCall)
}

func (fake *FakeTaskManager) PauseTaskForInputCalls(stub func(string, *types.Message) error) {
	fake.pauseTaskForInputMutex.Lock()
	defer fake.pauseTaskForInputMutex.Unlock()
	fake.PauseTaskForInputStub = stub
}

func (fake *FakeTaskManager) PauseTaskForInputArgsForCall(i int) (string, *types.Message) {
	fake.pauseTaskForInputMutex.RLock()
	defer fake.pauseTaskForInputMutex.RUnlock()
	argsForCall := fake.pauseTaskForInputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskManager) PauseTaskForInputReturns(result1 error) {
	fake.pauseTaskForInputMutex.Lock()
	defer fake.pauseTaskForInputMutex.Unlock()
	fake.PauseTaskForInputStub = nil
	fake.pauseTaskForInputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) PauseTaskForInputReturnsOnCall(i int, result1 error) {
	fake.pauseTaskForInputMutex.Lock()
	defer fake.pauseTaskForInputMutex.Unlock()
	fake.PauseTaskForInputStub = nil
	if fake.pauseTaskForInputReturnsOnCall == nil {
		fake.pauseTaskForInputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseTaskForInputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) PollTaskStatus(arg1 string, arg2 time.Duration, arg3 time.Duration) (*types.Task, error) {
	fake.pollTaskStatusMutex.Lock()
	ret, specificReturn := fake.pollTaskStatusReturnsOnCall[len(fake.pollTaskStatusArgsForCall)]
	fake.pollTaskStatusArgsForCall = append(fake.pollTaskStatusArgsForCall, struct {
		arg1 string
		arg2 time.Duration
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.PollTaskStatusStub
	fakeReturns := fake.pollTaskStatusReturns
	fake.recordInvocation("PollTaskStatus", []interface{}{arg1, arg2, arg3})
	fake.pollTaskStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) PollTaskStatusCallCount() int {
	fake.pollTaskStatusMutex.RLock()
	defer fake.pollTaskStatusMutex.RUnlock()
	return len(fake.pollTaskStatusArgsForCall)
}

func (fake *FakeTaskManager) PollTaskStatusCalls(stub func(string, time.Duration, time.Duration) (*types.Task, error)) {
	fake.pollTaskStatusMutex.Lock()
	defer fake.pollTaskStatusMutex.Unlock()
	fake.PollTaskStatusStub = stub
}

func (fake *FakeTaskManager) PollTaskStatusArgsForCall(i int) (string, time.Duration, time.Duration) {
	fake.pollTaskStatusMutex.RLock()
	defer fake.pollTaskStatusMutex.RUnlock()
	argsForCall := fake.pollTaskStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTaskManager) PollTaskStatusReturns(result1 *types.Task, result2 error) {
	fake.pollTaskStatusMutex.Lock()
	defer fake.pollTaskStatusMutex.Unlock()
	fake.PollTaskStatusStub = nil
	fake.pollTaskStatusReturns = struct {
		result1 *types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) PollTaskStatusReturnsOnCall(i int, result1 *types.Task, result2 error) {
	fake.pollTaskStatusMutex.Lock()
	defer fake.pollTaskStatusMutex.Unlock()
	fake.PollTaskStatusStub = nil
	if fake.pollTaskStatusReturnsOnCall == nil {
		fake.pollTaskStatusReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 error
		})
	}
	fake.pollTaskStatusReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) ResumeTaskWithInput(arg1 string, arg2 *types.Message) error {
	fake.resumeTaskWithInputMutex.Lock()
	ret, specificReturn := fake.resumeTaskWithInputReturnsOnCall[len(fake.resumeTaskWithInputArgsForCall)]
	fake.resumeTaskWithInputArgsForCall = append(fake.resumeTaskWithInputArgsForCall, struct {
		arg1 string
		arg2 *types.Message
	}{arg1, arg2})
	stub := fake.ResumeTaskWithInputStub
	fakeReturns := fake.resumeTaskWithInputReturns
	fake.recordInvocation("ResumeTaskWithInput", []interface{}{arg1, arg2})
	fake.resumeTaskWithInputMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) ResumeTaskWithInputCallCount() int {
	fake.resumeTaskWithInputMutex.RLock()
	defer fake.resumeTaskWithInputMutex.RUnlock()
	return len(fake.resumeTaskWithInputArgsForCall)
}

func (fake *FakeTaskManager) ResumeTaskWithInputCalls(stub func(string, *types.Message) error) {
	fake.resumeTaskWithInputMutex.Lock()
	defer fake.resumeTaskWithInputMutex.Unlock()
	fake.ResumeTaskWithInputStub = stub
}

func (fake *FakeTaskManager) ResumeTaskWithInputArgsForCall(i int) (string, *types.Message) {
	fake.resumeTaskWithInputMutex.RLock()
	defer fake.resumeTaskWithInputMutex.RUnlock()
	argsForCall := fake.resumeTaskWithInputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskManager) ResumeTaskWithInputReturns(result1 error) {
	fake.resumeTaskWithInputMutex.Lock()
	defer fake.resumeTaskWithInputMutex.Unlock()
	fake.ResumeTaskWithInputStub = nil
	fake.resumeTaskWithInputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) ResumeTaskWithInputReturnsOnCall(i int, result1 error) {
	fake.resumeTaskWithInputMutex.Lock()
	defer fake.resumeTaskWithInputMutex.Unlock()
	fake.ResumeTaskWithInputStub = nil
	if fake.resumeTaskWithInputReturnsOnCall == nil {
		fake.resumeTaskWithInputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resumeTaskWithInputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) SetRetentionConfig(arg1 config.TaskRetentionConfig) {
	fake.setRetentionConfigMutex.Lock()
	fake.setRetentionConfigArgsForCall = append(fake.setRetentionConfigArgsForCall, struct {
		arg1 config.TaskRetentionConfig
	}{arg1})
	stub := fake.SetRetentionConfigStub
	fake.recordInvocation("SetRetentionConfig", []interface{}{arg1})
	fake.setRetentionConfigMutex.Unlock()
	if stub != nil {
		fake.SetRetentionConfigStub(arg1)
	}
}

func (fake *FakeTaskManager) SetRetentionConfigCallCount() int {
	fake.setRetentionConfigMutex.RLock()
	defer fake.setRetentionConfigMutex.RUnlock()
	return len(fake.setRetentionConfigArgsForCall)
}

func (fake *FakeTaskManager) SetRetentionConfigCalls(stub func(config.TaskRetentionConfig)) {
	fake.setRetentionConfigMutex.Lock()
	defer fake.setRetentionConfigMutex.Unlock()
	fake.SetRetentionConfigStub = stub
}

func (fake *FakeTaskManager) SetRetentionConfigArgsForCall(i int) config.TaskRetentionConfig {
	fake.setRetentionConfigMutex.RLock()
	defer fake.setRetentionConfigMutex.RUnlock()
	argsForCall := fake.setRetentionConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfig(arg1 types.TaskPushNotificationConfig) (*types.TaskPushNotificationConfig, error) {
	fake.setTaskPushNotificationConfigMutex.Lock()
	ret, specificReturn := fake.setTaskPushNotificationConfigReturnsOnCall[len(fake.setTaskPushNotificationConfigArgsForCall)]
	fake.setTaskPushNotificationConfigArgsForCall = append(fake.setTaskPushNotificationConfigArgsForCall, struct {
		arg1 types.TaskPushNotificationConfig
	}{arg1})
	stub := fake.SetTaskPushNotificationConfigStub
	fakeReturns := fake.setTaskPushNotificationConfigReturns
	fake.recordInvocation("SetTaskPushNotificationConfig", []interface{}{arg1})
	fake.setTaskPushNotificationConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfigCallCount() int {
	fake.setTaskPushNotificationConfigMutex.RLock()
	defer fake.setTaskPushNotificationConfigMutex.RUnlock()
	return len(fake.setTaskPushNotificationConfigArgsForCall)
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfigCalls(stub func(types.TaskPushNotificationConfig) (*types.TaskPushNotificationConfig, error)) {
	fake.setTaskPushNotificationConfigMutex.Lock()
	defer fake.setTaskPushNotificationConfigMutex.Unlock()
	fake.SetTaskPushNotificationConfigStub = stub
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfigArgsForCall(i int) types.TaskPushNotificationConfig {
	fake.setTaskPushNotificationConfigMutex.RLock()
	defer fake.setTaskPushNotificationConfigMutex.RUnlock()
	argsForCall := fake.setTaskPushNotificationConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfigReturns(result1 *types.TaskPushNotificationConfig, result2 error) {
	fake.setTaskPushNotificationConfigMutex.Lock()
	defer fake.setTaskPushNotificationConfigMutex.Unlock()
	fake.SetTaskPushNotificationConfigStub = nil
	fake.setTaskPushNotificationConfigReturns = struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) SetTaskPushNotificationConfigReturnsOnCall(i int, result1 *types.TaskPushNotificationConfig, result2 error) {
	fake.setTaskPushNotificationConfigMutex.Lock()
	defer fake.setTaskPushNotificationConfigMutex.Unlock()
	fake.SetTaskPushNotificationConfigStub = nil
	if fake.setTaskPushNotificationConfigReturnsOnCall == nil {
		fake.setTaskPushNotificationConfigReturnsOnCall = make(map[int]struct {
			result1 *types.TaskPushNotificationConfig
			result2 error
		})
	}
	fake.setTaskPushNotificationConfigReturnsOnCall[i] = struct {
		result1 *types.TaskPushNotificationConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskManager) StopCleanup() {
	fake.stopCleanupMutex.Lock()
	fake.stopCleanupArgsForCall = append(fake.stopCleanupArgsForCall, struct {
	}{})
	stub := fake.StopCleanupStub
	fake.recordInvocation("StopCleanup", []interface{}{})
	fake.stopCleanupMutex.Unlock()
	if stub != nil {
		fake.StopCleanupStub()
	}
}

func (fake *FakeTaskManager) StopCleanupCallCount() int {
	fake.stopCleanupMutex.RLock()
	defer fake.stopCleanupMutex.RUnlock()
	return len(fake.stopCleanupArgsForCall)
}

func (fake *FakeTaskManager) StopCleanupCalls(stub func()) {
	fake.stopCleanupMutex.Lock()
	defer fake.stopCleanupMutex.Unlock()
	fake.StopCleanupStub = stub
}

func (fake *FakeTaskManager) UpdateConversationHistory(arg1 string, arg2 []types.Message) {
	var arg2Copy []types.Message
	if arg2 != nil {
		arg2Copy = make([]types.Message, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateConversationHistoryMutex.Lock()
	fake.updateConversationHistoryArgsForCall = append(fake.updateConversationHistoryArgsForCall, struct {
		arg1 string
		arg2 []types.Message
	}{arg1, arg2Copy})
	stub := fake.UpdateConversationHistoryStub
	fake.recordInvocation("UpdateConversationHistory", []interface{}{arg1, arg2Copy})
	fake.updateConversationHistoryMutex.Unlock()
	if stub != nil {
		fake.UpdateConversationHistoryStub(arg1, arg2)
	}
}

func (fake *FakeTaskManager) UpdateConversationHistoryCallCount() int {
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	return len(fake.updateConversationHistoryArgsForCall)
}

func (fake *FakeTaskManager) UpdateConversationHistoryCalls(stub func(string, []types.Message)) {
	fake.updateConversationHistoryMutex.Lock()
	defer fake.updateConversationHistoryMutex.Unlock()
	fake.UpdateConversationHistoryStub = stub
}

func (fake *FakeTaskManager) UpdateConversationHistoryArgsForCall(i int) (string, []types.Message) {
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	argsForCall := fake.updateConversationHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskManager) UpdateError(arg1 string, arg2 *types.Message) error {
	fake.updateErrorMutex.Lock()
	ret, specificReturn := fake.updateErrorReturnsOnCall[len(fake.updateErrorArgsForCall)]
	fake.updateErrorArgsForCall = append(fake.updateErrorArgsForCall, struct {
		arg1 string
		arg2 *types.Message
	}{arg1, arg2})
	stub := fake.UpdateErrorStub
	fakeReturns := fake.updateErrorReturns
	fake.recordInvocation("UpdateError", []interface{}{arg1, arg2})
	fake.updateErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) UpdateErrorCallCount() int {
	fake.updateErrorMutex.RLock()
	defer fake.updateErrorMutex.RUnlock()
	return len(fake.updateErrorArgsForCall)
}

func (fake *FakeTaskManager) UpdateErrorCalls(stub func(string, *types.Message) error) {
	fake.updateErrorMutex.Lock()
	defer fake.updateErrorMutex.Unlock()
	fake.UpdateErrorStub = stub
}

func (fake *FakeTaskManager) UpdateErrorArgsForCall(i int) (string, *types.Message) {
	fake.updateErrorMutex.RLock()
	defer fake.updateErrorMutex.RUnlock()
	argsForCall := fake.updateErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskManager) UpdateErrorReturns(result1 error) {
	fake.updateErrorMutex.Lock()
	defer fake.updateErrorMutex.Unlock()
	fake.UpdateErrorStub = nil
	fake.updateErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateErrorReturnsOnCall(i int, result1 error) {
	fake.updateErrorMutex.Lock()
	defer fake.updateErrorMutex.Unlock()
	fake.UpdateErrorStub = nil
	if fake.updateErrorReturnsOnCall == nil {
		fake.updateErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateState(arg1 string, arg2 types.TaskState) error {
	fake.updateStateMutex.Lock()
	ret, specificReturn := fake.updateStateReturnsOnCall[len(fake.updateStateArgsForCall)]
	fake.updateStateArgsForCall = append(fake.updateStateArgsForCall, struct {
		arg1 string
		arg2 types.TaskState
	}{arg1, arg2})
	stub := fake.UpdateStateStub
	fakeReturns := fake.updateStateReturns
	fake.recordInvocation("UpdateState", []interface{}{arg1, arg2})
	fake.updateStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) UpdateStateCallCount() int {
	fake.updateStateMutex.RLock()
	defer fake.updateStateMutex.RUnlock()
	return len(fake.updateStateArgsForCall)
}

func (fake *FakeTaskManager) UpdateStateCalls(stub func(string, types.TaskState) error) {
	fake.updateStateMutex.Lock()
	defer fake.updateStateMutex.Unlock()
	fake.UpdateStateStub = stub
}

func (fake *FakeTaskManager) UpdateStateArgsForCall(i int) (string, types.TaskState) {
	fake.updateStateMutex.RLock()
	defer fake.updateStateMutex.RUnlock()
	argsForCall := fake.updateStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskManager) UpdateStateReturns(result1 error) {
	fake.updateStateMutex.Lock()
	defer fake.updateStateMutex.Unlock()
	fake.UpdateStateStub = nil
	fake.updateStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateStateReturnsOnCall(i int, result1 error) {
	fake.updateStateMutex.Lock()
	defer fake.updateStateMutex.Unlock()
	fake.UpdateStateStub = nil
	if fake.updateStateReturnsOnCall == nil {
		fake.updateStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateTask(arg1 *types.Task) error {
	fake.updateTaskMutex.Lock()
	ret, specificReturn := fake.updateTaskReturnsOnCall[len(fake.updateTaskArgsForCall)]
	fake.updateTaskArgsForCall = append(fake.updateTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.UpdateTaskStub
	fakeReturns := fake.updateTaskReturns
	fake.recordInvocation("UpdateTask", []interface{}{arg1})
	fake.updateTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) UpdateTaskCallCount() int {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	return len(fake.updateTaskArgsForCall)
}

func (fake *FakeTaskManager) UpdateTaskCalls(stub func(*types.Task) error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = stub
}

func (fake *FakeTaskManager) UpdateTaskArgsForCall(i int) *types.Task {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	argsForCall := fake.updateTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) UpdateTaskReturns(result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	fake.updateTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateTaskReturnsOnCall(i int, result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	if fake.updateTaskReturnsOnCall == nil {
		fake.updateTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	fake.createTaskWithHistoryMutex.RLock()
	defer fake.createTaskWithHistoryMutex.RUnlock()
	fake.deleteTaskPushNotificationConfigMutex.RLock()
	defer fake.deleteTaskPushNotificationConfigMutex.RUnlock()
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.getTaskPushNotificationConfigMutex.RLock()
	defer fake.getTaskPushNotificationConfigMutex.RUnlock()
	fake.isTaskPausedMutex.RLock()
	defer fake.isTaskPausedMutex.RUnlock()
	fake.listTaskPushNotificationConfigsMutex.RLock()
	defer fake.listTaskPushNotificationConfigsMutex.RUnlock()
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	fake.pauseTaskForInputMutex.RLock()
	defer fake.pauseTaskForInputMutex.RUnlock()
	fake.pollTaskStatusMutex.RLock()
	defer fake.pollTaskStatusMutex.RUnlock()
	fake.resumeTaskWithInputMutex.RLock()
	defer fake.resumeTaskWithInputMutex.RUnlock()
	fake.setRetentionConfigMutex.RLock()
	defer fake.setRetentionConfigMutex.RUnlock()
	fake.setTaskPushNotificationConfigMutex.RLock()
	defer fake.setTaskPushNotificationConfigMutex.RUnlock()
	fake.stopCleanupMutex.RLock()
	defer fake.stopCleanupMutex.RUnlock()
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	fake.updateErrorMutex.RLock()
	defer fake.updateErrorMutex.RUnlock()
	fake.updateStateMutex.RLock()
	defer fake.updateStateMutex.RUnlock()
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTaskManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.TaskManager = new(FakeTaskManager)
