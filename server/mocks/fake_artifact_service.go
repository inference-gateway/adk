// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"io"
	"sync"
	"time"

	"github.com/inference-gateway/adk/server"
	"github.com/inference-gateway/adk/types"
)

type FakeArtifactService struct {
	AddArtifactToTaskStub        func(*types.Task, types.Artifact)
	addArtifactToTaskMutex       sync.RWMutex
	addArtifactToTaskArgsForCall []struct {
		arg1 *types.Task
		arg2 types.Artifact
	}
	AddArtifactsToTaskStub        func(*types.Task, []types.Artifact)
	addArtifactsToTaskMutex       sync.RWMutex
	addArtifactsToTaskArgsForCall []struct {
		arg1 *types.Task
		arg2 []types.Artifact
	}
	CleanupExpiredArtifactsStub        func(context.Context, time.Duration) (int, error)
	cleanupExpiredArtifactsMutex       sync.RWMutex
	cleanupExpiredArtifactsArgsForCall []struct {
		arg1 context.Context
		arg2 time.Duration
	}
	cleanupExpiredArtifactsReturns struct {
		result1 int
		result2 error
	}
	cleanupExpiredArtifactsReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	CleanupOldestArtifactsStub        func(context.Context, int) (int, error)
	cleanupOldestArtifactsMutex       sync.RWMutex
	cleanupOldestArtifactsArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	cleanupOldestArtifactsReturns struct {
		result1 int
		result2 error
	}
	cleanupOldestArtifactsReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateDataArtifactStub        func(string, string, map[string]any) types.Artifact
	createDataArtifactMutex       sync.RWMutex
	createDataArtifactArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 map[string]any
	}
	createDataArtifactReturns struct {
		result1 types.Artifact
	}
	createDataArtifactReturnsOnCall map[int]struct {
		result1 types.Artifact
	}
	CreateFileArtifactStub        func(string, string, string, []byte, *string) (types.Artifact, error)
	createFileArtifactMutex       sync.RWMutex
	createFileArtifactArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 *string
	}
	createFileArtifactReturns struct {
		result1 types.Artifact
		result2 error
	}
	createFileArtifactReturnsOnCall map[int]struct {
		result1 types.Artifact
		result2 error
	}
	CreateFileArtifactFromURIStub        func(string, string, string, string, *string) types.Artifact
	createFileArtifactFromURIMutex       sync.RWMutex
	createFileArtifactFromURIArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *string
	}
	createFileArtifactFromURIReturns struct {
		result1 types.Artifact
	}
	createFileArtifactFromURIReturnsOnCall map[int]struct {
		result1 types.Artifact
	}
	CreateMultiPartArtifactStub        func(string, string, []types.Part) types.Artifact
	createMultiPartArtifactMutex       sync.RWMutex
	createMultiPartArtifactArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []types.Part
	}
	createMultiPartArtifactReturns struct {
		result1 types.Artifact
	}
	createMultiPartArtifactReturnsOnCall map[int]struct {
		result1 types.Artifact
	}
	CreateTaskArtifactUpdateEventStub        func(string, string, types.Artifact, *bool, *bool) types.TaskArtifactUpdateEvent
	createTaskArtifactUpdateEventMutex       sync.RWMutex
	createTaskArtifactUpdateEventArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 types.Artifact
		arg4 *bool
		arg5 *bool
	}
	createTaskArtifactUpdateEventReturns struct {
		result1 types.TaskArtifactUpdateEvent
	}
	createTaskArtifactUpdateEventReturnsOnCall map[int]struct {
		result1 types.TaskArtifactUpdateEvent
	}
	CreateTextArtifactStub        func(string, string, string) types.Artifact
	createTextArtifactMutex       sync.RWMutex
	createTextArtifactArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	createTextArtifactReturns struct {
		result1 types.Artifact
	}
	createTextArtifactReturnsOnCall map[int]struct {
		result1 types.Artifact
	}
	ExistsStub        func(context.Context, string, string) (bool, error)
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	existsReturns struct {
		result1 bool
		result2 error
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetArtifactByIDStub        func(*types.Task, string) (*types.Artifact, bool)
	getArtifactByIDMutex       sync.RWMutex
	getArtifactByIDArgsForCall []struct {
		arg1 *types.Task
		arg2 string
	}
	getArtifactByIDReturns struct {
		result1 *types.Artifact
		result2 bool
	}
	getArtifactByIDReturnsOnCall map[int]struct {
		result1 *types.Artifact
		result2 bool
	}
	GetArtifactsByTypeStub        func(*types.Task, string) []types.Artifact
	getArtifactsByTypeMutex       sync.RWMutex
	getArtifactsByTypeArgsForCall []struct {
		arg1 *types.Task
		arg2 string
	}
	getArtifactsByTypeReturns struct {
		result1 []types.Artifact
	}
	getArtifactsByTypeReturnsOnCall map[int]struct {
		result1 []types.Artifact
	}
	GetMimeTypeFromExtensionStub        func(string) *string
	getMimeTypeFromExtensionMutex       sync.RWMutex
	getMimeTypeFromExtensionArgsForCall []struct {
		arg1 string
	}
	getMimeTypeFromExtensionReturns struct {
		result1 *string
	}
	getMimeTypeFromExtensionReturnsOnCall map[int]struct {
		result1 *string
	}
	RetrieveStub        func(context.Context, string, string) (io.ReadCloser, error)
	retrieveMutex       sync.RWMutex
	retrieveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	retrieveReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	retrieveReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ValidateArtifactStub        func(types.Artifact) error
	validateArtifactMutex       sync.RWMutex
	validateArtifactArgsForCall []struct {
		arg1 types.Artifact
	}
	validateArtifactReturns struct {
		result1 error
	}
	validateArtifactReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeArtifactService) AddArtifactToTask(arg1 *types.Task, arg2 types.Artifact) {
	fake.addArtifactToTaskMutex.Lock()
	fake.addArtifactToTaskArgsForCall = append(fake.addArtifactToTaskArgsForCall, struct {
		arg1 *types.Task
		arg2 types.Artifact
	}{arg1, arg2})
	stub := fake.AddArtifactToTaskStub
	fake.recordInvocation("AddArtifactToTask", []interface{}{arg1, arg2})
	fake.addArtifactToTaskMutex.Unlock()
	if stub != nil {
		fake.AddArtifactToTaskStub(arg1, arg2)
	}
}

func (fake *FakeArtifactService) AddArtifactToTaskCallCount() int {
	fake.addArtifactToTaskMutex.RLock()
	defer fake.addArtifactToTaskMutex.RUnlock()
	return len(fake.addArtifactToTaskArgsForCall)
}

func (fake *FakeArtifactService) AddArtifactToTaskCalls(stub func(*types.Task, types.Artifact)) {
	fake.addArtifactToTaskMutex.Lock()
	defer fake.addArtifactToTaskMutex.Unlock()
	fake.AddArtifactToTaskStub = stub
}

func (fake *FakeArtifactService) AddArtifactToTaskArgsForCall(i int) (*types.Task, types.Artifact) {
	fake.addArtifactToTaskMutex.RLock()
	defer fake.addArtifactToTaskMutex.RUnlock()
	argsForCall := fake.addArtifactToTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) AddArtifactsToTask(arg1 *types.Task, arg2 []types.Artifact) {
	var arg2Copy []types.Artifact
	if arg2 != nil {
		arg2Copy = make([]types.Artifact, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addArtifactsToTaskMutex.Lock()
	fake.addArtifactsToTaskArgsForCall = append(fake.addArtifactsToTaskArgsForCall, struct {
		arg1 *types.Task
		arg2 []types.Artifact
	}{arg1, arg2Copy})
	stub := fake.AddArtifactsToTaskStub
	fake.recordInvocation("AddArtifactsToTask", []interface{}{arg1, arg2Copy})
	fake.addArtifactsToTaskMutex.Unlock()
	if stub != nil {
		fake.AddArtifactsToTaskStub(arg1, arg2)
	}
}

func (fake *FakeArtifactService) AddArtifactsToTaskCallCount() int {
	fake.addArtifactsToTaskMutex.RLock()
	defer fake.addArtifactsToTaskMutex.RUnlock()
	return len(fake.addArtifactsToTaskArgsForCall)
}

func (fake *FakeArtifactService) AddArtifactsToTaskCalls(stub func(*types.Task, []types.Artifact)) {
	fake.addArtifactsToTaskMutex.Lock()
	defer fake.addArtifactsToTaskMutex.Unlock()
	fake.AddArtifactsToTaskStub = stub
}

func (fake *FakeArtifactService) AddArtifactsToTaskArgsForCall(i int) (*types.Task, []types.Artifact) {
	fake.addArtifactsToTaskMutex.RLock()
	defer fake.addArtifactsToTaskMutex.RUnlock()
	argsForCall := fake.addArtifactsToTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) CleanupExpiredArtifacts(arg1 context.Context, arg2 time.Duration) (int, error) {
	fake.cleanupExpiredArtifactsMutex.Lock()
	ret, specificReturn := fake.cleanupExpiredArtifactsReturnsOnCall[len(fake.cleanupExpiredArtifactsArgsForCall)]
	fake.cleanupExpiredArtifactsArgsForCall = append(fake.cleanupExpiredArtifactsArgsForCall, struct {
		arg1 context.Context
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.CleanupExpiredArtifactsStub
	fakeReturns := fake.cleanupExpiredArtifactsReturns
	fake.recordInvocation("CleanupExpiredArtifacts", []interface{}{arg1, arg2})
	fake.cleanupExpiredArtifactsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) CleanupExpiredArtifactsCallCount() int {
	fake.cleanupExpiredArtifactsMutex.RLock()
	defer fake.cleanupExpiredArtifactsMutex.RUnlock()
	return len(fake.cleanupExpiredArtifactsArgsForCall)
}

func (fake *FakeArtifactService) CleanupExpiredArtifactsCalls(stub func(context.Context, time.Duration) (int, error)) {
	fake.cleanupExpiredArtifactsMutex.Lock()
	defer fake.cleanupExpiredArtifactsMutex.Unlock()
	fake.CleanupExpiredArtifactsStub = stub
}

func (fake *FakeArtifactService) CleanupExpiredArtifactsArgsForCall(i int) (context.Context, time.Duration) {
	fake.cleanupExpiredArtifactsMutex.RLock()
	defer fake.cleanupExpiredArtifactsMutex.RUnlock()
	argsForCall := fake.cleanupExpiredArtifactsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) CleanupExpiredArtifactsReturns(result1 int, result2 error) {
	fake.cleanupExpiredArtifactsMutex.Lock()
	defer fake.cleanupExpiredArtifactsMutex.Unlock()
	fake.CleanupExpiredArtifactsStub = nil
	fake.cleanupExpiredArtifactsReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) CleanupExpiredArtifactsReturnsOnCall(i int, result1 int, result2 error) {
	fake.cleanupExpiredArtifactsMutex.Lock()
	defer fake.cleanupExpiredArtifactsMutex.Unlock()
	fake.CleanupExpiredArtifactsStub = nil
	if fake.cleanupExpiredArtifactsReturnsOnCall == nil {
		fake.cleanupExpiredArtifactsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.cleanupExpiredArtifactsReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) CleanupOldestArtifacts(arg1 context.Context, arg2 int) (int, error) {
	fake.cleanupOldestArtifactsMutex.Lock()
	ret, specificReturn := fake.cleanupOldestArtifactsReturnsOnCall[len(fake.cleanupOldestArtifactsArgsForCall)]
	fake.cleanupOldestArtifactsArgsForCall = append(fake.cleanupOldestArtifactsArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.CleanupOldestArtifactsStub
	fakeReturns := fake.cleanupOldestArtifactsReturns
	fake.recordInvocation("CleanupOldestArtifacts", []interface{}{arg1, arg2})
	fake.cleanupOldestArtifactsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) CleanupOldestArtifactsCallCount() int {
	fake.cleanupOldestArtifactsMutex.RLock()
	defer fake.cleanupOldestArtifactsMutex.RUnlock()
	return len(fake.cleanupOldestArtifactsArgsForCall)
}

func (fake *FakeArtifactService) CleanupOldestArtifactsCalls(stub func(context.Context, int) (int, error)) {
	fake.cleanupOldestArtifactsMutex.Lock()
	defer fake.cleanupOldestArtifactsMutex.Unlock()
	fake.CleanupOldestArtifactsStub = stub
}

func (fake *FakeArtifactService) CleanupOldestArtifactsArgsForCall(i int) (context.Context, int) {
	fake.cleanupOldestArtifactsMutex.RLock()
	defer fake.cleanupOldestArtifactsMutex.RUnlock()
	argsForCall := fake.cleanupOldestArtifactsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) CleanupOldestArtifactsReturns(result1 int, result2 error) {
	fake.cleanupOldestArtifactsMutex.Lock()
	defer fake.cleanupOldestArtifactsMutex.Unlock()
	fake.CleanupOldestArtifactsStub = nil
	fake.cleanupOldestArtifactsReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) CleanupOldestArtifactsReturnsOnCall(i int, result1 int, result2 error) {
	fake.cleanupOldestArtifactsMutex.Lock()
	defer fake.cleanupOldestArtifactsMutex.Unlock()
	fake.CleanupOldestArtifactsStub = nil
	if fake.cleanupOldestArtifactsReturnsOnCall == nil {
		fake.cleanupOldestArtifactsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.cleanupOldestArtifactsReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeArtifactService) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeArtifactService) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifactService) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifactService) CreateDataArtifact(arg1 string, arg2 string, arg3 map[string]any) types.Artifact {
	fake.createDataArtifactMutex.Lock()
	ret, specificReturn := fake.createDataArtifactReturnsOnCall[len(fake.createDataArtifactArgsForCall)]
	fake.createDataArtifactArgsForCall = append(fake.createDataArtifactArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 map[string]any
	}{arg1, arg2, arg3})
	stub := fake.CreateDataArtifactStub
	fakeReturns := fake.createDataArtifactReturns
	fake.recordInvocation("CreateDataArtifact", []interface{}{arg1, arg2, arg3})
	fake.createDataArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CreateDataArtifactCallCount() int {
	fake.createDataArtifactMutex.RLock()
	defer fake.createDataArtifactMutex.RUnlock()
	return len(fake.createDataArtifactArgsForCall)
}

func (fake *FakeArtifactService) CreateDataArtifactCalls(stub func(string, string, map[string]any) types.Artifact) {
	fake.createDataArtifactMutex.Lock()
	defer fake.createDataArtifactMutex.Unlock()
	fake.CreateDataArtifactStub = stub
}

func (fake *FakeArtifactService) CreateDataArtifactArgsForCall(i int) (string, string, map[string]any) {
	fake.createDataArtifactMutex.RLock()
	defer fake.createDataArtifactMutex.RUnlock()
	argsForCall := fake.createDataArtifactArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtifactService) CreateDataArtifactReturns(result1 types.Artifact) {
	fake.createDataArtifactMutex.Lock()
	defer fake.createDataArtifactMutex.Unlock()
	fake.CreateDataArtifactStub = nil
	fake.createDataArtifactReturns = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateDataArtifactReturnsOnCall(i int, result1 types.Artifact) {
	fake.createDataArtifactMutex.Lock()
	defer fake.createDataArtifactMutex.Unlock()
	fake.CreateDataArtifactStub = nil
	if fake.createDataArtifactReturnsOnCall == nil {
		fake.createDataArtifactReturnsOnCall = make(map[int]struct {
			result1 types.Artifact
		})
	}
	fake.createDataArtifactReturnsOnCall[i] = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateFileArtifact(arg1 string, arg2 string, arg3 string, arg4 []byte, arg5 *string) (types.Artifact, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.createFileArtifactMutex.Lock()
	ret, specificReturn := fake.createFileArtifactReturnsOnCall[len(fake.createFileArtifactArgsForCall)]
	fake.createFileArtifactArgsForCall = append(fake.createFileArtifactArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 *string
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.CreateFileArtifactStub
	fakeReturns := fake.createFileArtifactReturns
	fake.recordInvocation("CreateFileArtifact", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.createFileArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) CreateFileArtifactCallCount() int {
	fake.createFileArtifactMutex.RLock()
	defer fake.createFileArtifactMutex.RUnlock()
	return len(fake.createFileArtifactArgsForCall)
}

func (fake *FakeArtifactService) CreateFileArtifactCalls(stub func(string, string, string, []byte, *string) (types.Artifact, error)) {
	fake.createFileArtifactMutex.Lock()
	defer fake.createFileArtifactMutex.Unlock()
	fake.CreateFileArtifactStub = stub
}

func (fake *FakeArtifactService) CreateFileArtifactArgsForCall(i int) (string, string, string, []byte, *string) {
	fake.createFileArtifactMutex.RLock()
	defer fake.createFileArtifactMutex.RUnlock()
	argsForCall := fake.createFileArtifactArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeArtifactService) CreateFileArtifactReturns(result1 types.Artifact, result2 error) {
	fake.createFileArtifactMutex.Lock()
	defer fake.createFileArtifactMutex.Unlock()
	fake.CreateFileArtifactStub = nil
	fake.createFileArtifactReturns = struct {
		result1 types.Artifact
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) CreateFileArtifactReturnsOnCall(i int, result1 types.Artifact, result2 error) {
	fake.createFileArtifactMutex.Lock()
	defer fake.createFileArtifactMutex.Unlock()
	fake.CreateFileArtifactStub = nil
	if fake.createFileArtifactReturnsOnCall == nil {
		fake.createFileArtifactReturnsOnCall = make(map[int]struct {
			result1 types.Artifact
			result2 error
		})
	}
	fake.createFileArtifactReturnsOnCall[i] = struct {
		result1 types.Artifact
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) CreateFileArtifactFromURI(arg1 string, arg2 string, arg3 string, arg4 string, arg5 *string) types.Artifact {
	fake.createFileArtifactFromURIMutex.Lock()
	ret, specificReturn := fake.createFileArtifactFromURIReturnsOnCall[len(fake.createFileArtifactFromURIArgsForCall)]
	fake.createFileArtifactFromURIArgsForCall = append(fake.createFileArtifactFromURIArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateFileArtifactFromURIStub
	fakeReturns := fake.createFileArtifactFromURIReturns
	fake.recordInvocation("CreateFileArtifactFromURI", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createFileArtifactFromURIMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CreateFileArtifactFromURICallCount() int {
	fake.createFileArtifactFromURIMutex.RLock()
	defer fake.createFileArtifactFromURIMutex.RUnlock()
	return len(fake.createFileArtifactFromURIArgsForCall)
}

func (fake *FakeArtifactService) CreateFileArtifactFromURICalls(stub func(string, string, string, string, *string) types.Artifact) {
	fake.createFileArtifactFromURIMutex.Lock()
	defer fake.createFileArtifactFromURIMutex.Unlock()
	fake.CreateFileArtifactFromURIStub = stub
}

func (fake *FakeArtifactService) CreateFileArtifactFromURIArgsForCall(i int) (string, string, string, string, *string) {
	fake.createFileArtifactFromURIMutex.RLock()
	defer fake.createFileArtifactFromURIMutex.RUnlock()
	argsForCall := fake.createFileArtifactFromURIArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeArtifactService) CreateFileArtifactFromURIReturns(result1 types.Artifact) {
	fake.createFileArtifactFromURIMutex.Lock()
	defer fake.createFileArtifactFromURIMutex.Unlock()
	fake.CreateFileArtifactFromURIStub = nil
	fake.createFileArtifactFromURIReturns = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateFileArtifactFromURIReturnsOnCall(i int, result1 types.Artifact) {
	fake.createFileArtifactFromURIMutex.Lock()
	defer fake.createFileArtifactFromURIMutex.Unlock()
	fake.CreateFileArtifactFromURIStub = nil
	if fake.createFileArtifactFromURIReturnsOnCall == nil {
		fake.createFileArtifactFromURIReturnsOnCall = make(map[int]struct {
			result1 types.Artifact
		})
	}
	fake.createFileArtifactFromURIReturnsOnCall[i] = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateMultiPartArtifact(arg1 string, arg2 string, arg3 []types.Part) types.Artifact {
	var arg3Copy []types.Part
	if arg3 != nil {
		arg3Copy = make([]types.Part, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createMultiPartArtifactMutex.Lock()
	ret, specificReturn := fake.createMultiPartArtifactReturnsOnCall[len(fake.createMultiPartArtifactArgsForCall)]
	fake.createMultiPartArtifactArgsForCall = append(fake.createMultiPartArtifactArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []types.Part
	}{arg1, arg2, arg3Copy})
	stub := fake.CreateMultiPartArtifactStub
	fakeReturns := fake.createMultiPartArtifactReturns
	fake.recordInvocation("CreateMultiPartArtifact", []interface{}{arg1, arg2, arg3Copy})
	fake.createMultiPartArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CreateMultiPartArtifactCallCount() int {
	fake.createMultiPartArtifactMutex.RLock()
	defer fake.createMultiPartArtifactMutex.RUnlock()
	return len(fake.createMultiPartArtifactArgsForCall)
}

func (fake *FakeArtifactService) CreateMultiPartArtifactCalls(stub func(string, string, []types.Part) types.Artifact) {
	fake.createMultiPartArtifactMutex.Lock()
	defer fake.createMultiPartArtifactMutex.Unlock()
	fake.CreateMultiPartArtifactStub = stub
}

func (fake *FakeArtifactService) CreateMultiPartArtifactArgsForCall(i int) (string, string, []types.Part) {
	fake.createMultiPartArtifactMutex.RLock()
	defer fake.createMultiPartArtifactMutex.RUnlock()
	argsForCall := fake.createMultiPartArtifactArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtifactService) CreateMultiPartArtifactReturns(result1 types.Artifact) {
	fake.createMultiPartArtifactMutex.Lock()
	defer fake.createMultiPartArtifactMutex.Unlock()
	fake.CreateMultiPartArtifactStub = nil
	fake.createMultiPartArtifactReturns = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateMultiPartArtifactReturnsOnCall(i int, result1 types.Artifact) {
	fake.createMultiPartArtifactMutex.Lock()
	defer fake.createMultiPartArtifactMutex.Unlock()
	fake.CreateMultiPartArtifactStub = nil
	if fake.createMultiPartArtifactReturnsOnCall == nil {
		fake.createMultiPartArtifactReturnsOnCall = make(map[int]struct {
			result1 types.Artifact
		})
	}
	fake.createMultiPartArtifactReturnsOnCall[i] = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEvent(arg1 string, arg2 string, arg3 types.Artifact, arg4 *bool, arg5 *bool) types.TaskArtifactUpdateEvent {
	fake.createTaskArtifactUpdateEventMutex.Lock()
	ret, specificReturn := fake.createTaskArtifactUpdateEventReturnsOnCall[len(fake.createTaskArtifactUpdateEventArgsForCall)]
	fake.createTaskArtifactUpdateEventArgsForCall = append(fake.createTaskArtifactUpdateEventArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 types.Artifact
		arg4 *bool
		arg5 *bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateTaskArtifactUpdateEventStub
	fakeReturns := fake.createTaskArtifactUpdateEventReturns
	fake.recordInvocation("CreateTaskArtifactUpdateEvent", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createTaskArtifactUpdateEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEventCallCount() int {
	fake.createTaskArtifactUpdateEventMutex.RLock()
	defer fake.createTaskArtifactUpdateEventMutex.RUnlock()
	return len(fake.createTaskArtifactUpdateEventArgsForCall)
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEventCalls(stub func(string, string, types.Artifact, *bool, *bool) types.TaskArtifactUpdateEvent) {
	fake.createTaskArtifactUpdateEventMutex.Lock()
	defer fake.createTaskArtifactUpdateEventMutex.Unlock()
	fake.CreateTaskArtifactUpdateEventStub = stub
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEventArgsForCall(i int) (string, string, types.Artifact, *bool, *bool) {
	fake.createTaskArtifactUpdateEventMutex.RLock()
	defer fake.createTaskArtifactUpdateEventMutex.RUnlock()
	argsForCall := fake.createTaskArtifactUpdateEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEventReturns(result1 types.TaskArtifactUpdateEvent) {
	fake.createTaskArtifactUpdateEventMutex.Lock()
	defer fake.createTaskArtifactUpdateEventMutex.Unlock()
	fake.CreateTaskArtifactUpdateEventStub = nil
	fake.createTaskArtifactUpdateEventReturns = struct {
		result1 types.TaskArtifactUpdateEvent
	}{result1}
}

func (fake *FakeArtifactService) CreateTaskArtifactUpdateEventReturnsOnCall(i int, result1 types.TaskArtifactUpdateEvent) {
	fake.createTaskArtifactUpdateEventMutex.Lock()
	defer fake.createTaskArtifactUpdateEventMutex.Unlock()
	fake.CreateTaskArtifactUpdateEventStub = nil
	if fake.createTaskArtifactUpdateEventReturnsOnCall == nil {
		fake.createTaskArtifactUpdateEventReturnsOnCall = make(map[int]struct {
			result1 types.TaskArtifactUpdateEvent
		})
	}
	fake.createTaskArtifactUpdateEventReturnsOnCall[i] = struct {
		result1 types.TaskArtifactUpdateEvent
	}{result1}
}

func (fake *FakeArtifactService) CreateTextArtifact(arg1 string, arg2 string, arg3 string) types.Artifact {
	fake.createTextArtifactMutex.Lock()
	ret, specificReturn := fake.createTextArtifactReturnsOnCall[len(fake.createTextArtifactArgsForCall)]
	fake.createTextArtifactArgsForCall = append(fake.createTextArtifactArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateTextArtifactStub
	fakeReturns := fake.createTextArtifactReturns
	fake.recordInvocation("CreateTextArtifact", []interface{}{arg1, arg2, arg3})
	fake.createTextArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) CreateTextArtifactCallCount() int {
	fake.createTextArtifactMutex.RLock()
	defer fake.createTextArtifactMutex.RUnlock()
	return len(fake.createTextArtifactArgsForCall)
}

func (fake *FakeArtifactService) CreateTextArtifactCalls(stub func(string, string, string) types.Artifact) {
	fake.createTextArtifactMutex.Lock()
	defer fake.createTextArtifactMutex.Unlock()
	fake.CreateTextArtifactStub = stub
}

func (fake *FakeArtifactService) CreateTextArtifactArgsForCall(i int) (string, string, string) {
	fake.createTextArtifactMutex.RLock()
	defer fake.createTextArtifactMutex.RUnlock()
	argsForCall := fake.createTextArtifactArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtifactService) CreateTextArtifactReturns(result1 types.Artifact) {
	fake.createTextArtifactMutex.Lock()
	defer fake.createTextArtifactMutex.Unlock()
	fake.CreateTextArtifactStub = nil
	fake.createTextArtifactReturns = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) CreateTextArtifactReturnsOnCall(i int, result1 types.Artifact) {
	fake.createTextArtifactMutex.Lock()
	defer fake.createTextArtifactMutex.Unlock()
	fake.CreateTextArtifactStub = nil
	if fake.createTextArtifactReturnsOnCall == nil {
		fake.createTextArtifactReturnsOnCall = make(map[int]struct {
			result1 types.Artifact
		})
	}
	fake.createTextArtifactReturnsOnCall[i] = struct {
		result1 types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) Exists(arg1 context.Context, arg2 string, arg3 string) (bool, error) {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1, arg2, arg3})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakeArtifactService) ExistsCalls(stub func(context.Context, string, string) (bool, error)) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakeArtifactService) ExistsArgsForCall(i int) (context.Context, string, string) {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtifactService) ExistsReturns(result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) ExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) GetArtifactByID(arg1 *types.Task, arg2 string) (*types.Artifact, bool) {
	fake.getArtifactByIDMutex.Lock()
	ret, specificReturn := fake.getArtifactByIDReturnsOnCall[len(fake.getArtifactByIDArgsForCall)]
	fake.getArtifactByIDArgsForCall = append(fake.getArtifactByIDArgsForCall, struct {
		arg1 *types.Task
		arg2 string
	}{arg1, arg2})
	stub := fake.GetArtifactByIDStub
	fakeReturns := fake.getArtifactByIDReturns
	fake.recordInvocation("GetArtifactByID", []interface{}{arg1, arg2})
	fake.getArtifactByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) GetArtifactByIDCallCount() int {
	fake.getArtifactByIDMutex.RLock()
	defer fake.getArtifactByIDMutex.RUnlock()
	return len(fake.getArtifactByIDArgsForCall)
}

func (fake *FakeArtifactService) GetArtifactByIDCalls(stub func(*types.Task, string) (*types.Artifact, bool)) {
	fake.getArtifactByIDMutex.Lock()
	defer fake.getArtifactByIDMutex.Unlock()
	fake.GetArtifactByIDStub = stub
}

func (fake *FakeArtifactService) GetArtifactByIDArgsForCall(i int) (*types.Task, string) {
	fake.getArtifactByIDMutex.RLock()
	defer fake.getArtifactByIDMutex.RUnlock()
	argsForCall := fake.getArtifactByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) GetArtifactByIDReturns(result1 *types.Artifact, result2 bool) {
	fake.getArtifactByIDMutex.Lock()
	defer fake.getArtifactByIDMutex.Unlock()
	fake.GetArtifactByIDStub = nil
	fake.getArtifactByIDReturns = struct {
		result1 *types.Artifact
		result2 bool
	}{result1, result2}
}

func (fake *FakeArtifactService) GetArtifactByIDReturnsOnCall(i int, result1 *types.Artifact, result2 bool) {
	fake.getArtifactByIDMutex.Lock()
	defer fake.getArtifactByIDMutex.Unlock()
	fake.GetArtifactByIDStub = nil
	if fake.getArtifactByIDReturnsOnCall == nil {
		fake.getArtifactByIDReturnsOnCall = make(map[int]struct {
			result1 *types.Artifact
			result2 bool
		})
	}
	fake.getArtifactByIDReturnsOnCall[i] = struct {
		result1 *types.Artifact
		result2 bool
	}{result1, result2}
}

func (fake *FakeArtifactService) GetArtifactsByType(arg1 *types.Task, arg2 string) []types.Artifact {
	fake.getArtifactsByTypeMutex.Lock()
	ret, specificReturn := fake.getArtifactsByTypeReturnsOnCall[len(fake.getArtifactsByTypeArgsForCall)]
	fake.getArtifactsByTypeArgsForCall = append(fake.getArtifactsByTypeArgsForCall, struct {
		arg1 *types.Task
		arg2 string
	}{arg1, arg2})
	stub := fake.GetArtifactsByTypeStub
	fakeReturns := fake.getArtifactsByTypeReturns
	fake.recordInvocation("GetArtifactsByType", []interface{}{arg1, arg2})
	fake.getArtifactsByTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) GetArtifactsByTypeCallCount() int {
	fake.getArtifactsByTypeMutex.RLock()
	defer fake.getArtifactsByTypeMutex.RUnlock()
	return len(fake.getArtifactsByTypeArgsForCall)
}

func (fake *FakeArtifactService) GetArtifactsByTypeCalls(stub func(*types.Task, string) []types.Artifact) {
	fake.getArtifactsByTypeMutex.Lock()
	defer fake.getArtifactsByTypeMutex.Unlock()
	fake.GetArtifactsByTypeStub = stub
}

func (fake *FakeArtifactService) GetArtifactsByTypeArgsForCall(i int) (*types.Task, string) {
	fake.getArtifactsByTypeMutex.RLock()
	defer fake.getArtifactsByTypeMutex.RUnlock()
	argsForCall := fake.getArtifactsByTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeArtifactService) GetArtifactsByTypeReturns(result1 []types.Artifact) {
	fake.getArtifactsByTypeMutex.Lock()
	defer fake.getArtifactsByTypeMutex.Unlock()
	fake.GetArtifactsByTypeStub = nil
	fake.getArtifactsByTypeReturns = struct {
		result1 []types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) GetArtifactsByTypeReturnsOnCall(i int, result1 []types.Artifact) {
	fake.getArtifactsByTypeMutex.Lock()
	defer fake.getArtifactsByTypeMutex.Unlock()
	fake.GetArtifactsByTypeStub = nil
	if fake.getArtifactsByTypeReturnsOnCall == nil {
		fake.getArtifactsByTypeReturnsOnCall = make(map[int]struct {
			result1 []types.Artifact
		})
	}
	fake.getArtifactsByTypeReturnsOnCall[i] = struct {
		result1 []types.Artifact
	}{result1}
}

func (fake *FakeArtifactService) GetMimeTypeFromExtension(arg1 string) *string {
	fake.getMimeTypeFromExtensionMutex.Lock()
	ret, specificReturn := fake.getMimeTypeFromExtensionReturnsOnCall[len(fake.getMimeTypeFromExtensionArgsForCall)]
	fake.getMimeTypeFromExtensionArgsForCall = append(fake.getMimeTypeFromExtensionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetMimeTypeFromExtensionStub
	fakeReturns := fake.getMimeTypeFromExtensionReturns
	fake.recordInvocation("GetMimeTypeFromExtension", []interface{}{arg1})
	fake.getMimeTypeFromExtensionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) GetMimeTypeFromExtensionCallCount() int {
	fake.getMimeTypeFromExtensionMutex.RLock()
	defer fake.getMimeTypeFromExtensionMutex.RUnlock()
	return len(fake.getMimeTypeFromExtensionArgsForCall)
}

func (fake *FakeArtifactService) GetMimeTypeFromExtensionCalls(stub func(string) *string) {
	fake.getMimeTypeFromExtensionMutex.Lock()
	defer fake.getMimeTypeFromExtensionMutex.Unlock()
	fake.GetMimeTypeFromExtensionStub = stub
}

func (fake *FakeArtifactService) GetMimeTypeFromExtensionArgsForCall(i int) string {
	fake.getMimeTypeFromExtensionMutex.RLock()
	defer fake.getMimeTypeFromExtensionMutex.RUnlock()
	argsForCall := fake.getMimeTypeFromExtensionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeArtifactService) GetMimeTypeFromExtensionReturns(result1 *string) {
	fake.getMimeTypeFromExtensionMutex.Lock()
	defer fake.getMimeTypeFromExtensionMutex.Unlock()
	fake.GetMimeTypeFromExtensionStub = nil
	fake.getMimeTypeFromExtensionReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeArtifactService) GetMimeTypeFromExtensionReturnsOnCall(i int, result1 *string) {
	fake.getMimeTypeFromExtensionMutex.Lock()
	defer fake.getMimeTypeFromExtensionMutex.Unlock()
	fake.GetMimeTypeFromExtensionStub = nil
	if fake.getMimeTypeFromExtensionReturnsOnCall == nil {
		fake.getMimeTypeFromExtensionReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.getMimeTypeFromExtensionReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeArtifactService) Retrieve(arg1 context.Context, arg2 string, arg3 string) (io.ReadCloser, error) {
	fake.retrieveMutex.Lock()
	ret, specificReturn := fake.retrieveReturnsOnCall[len(fake.retrieveArgsForCall)]
	fake.retrieveArgsForCall = append(fake.retrieveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RetrieveStub
	fakeReturns := fake.retrieveReturns
	fake.recordInvocation("Retrieve", []interface{}{arg1, arg2, arg3})
	fake.retrieveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeArtifactService) RetrieveCallCount() int {
	fake.retrieveMutex.RLock()
	defer fake.retrieveMutex.RUnlock()
	return len(fake.retrieveArgsForCall)
}

func (fake *FakeArtifactService) RetrieveCalls(stub func(context.Context, string, string) (io.ReadCloser, error)) {
	fake.retrieveMutex.Lock()
	defer fake.retrieveMutex.Unlock()
	fake.RetrieveStub = stub
}

func (fake *FakeArtifactService) RetrieveArgsForCall(i int) (context.Context, string, string) {
	fake.retrieveMutex.RLock()
	defer fake.retrieveMutex.RUnlock()
	argsForCall := fake.retrieveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeArtifactService) RetrieveReturns(result1 io.ReadCloser, result2 error) {
	fake.retrieveMutex.Lock()
	defer fake.retrieveMutex.Unlock()
	fake.RetrieveStub = nil
	fake.retrieveReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) RetrieveReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.retrieveMutex.Lock()
	defer fake.retrieveMutex.Unlock()
	fake.RetrieveStub = nil
	if fake.retrieveReturnsOnCall == nil {
		fake.retrieveReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.retrieveReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifactService) ValidateArtifact(arg1 types.Artifact) error {
	fake.validateArtifactMutex.Lock()
	ret, specificReturn := fake.validateArtifactReturnsOnCall[len(fake.validateArtifactArgsForCall)]
	fake.validateArtifactArgsForCall = append(fake.validateArtifactArgsForCall, struct {
		arg1 types.Artifact
	}{arg1})
	stub := fake.ValidateArtifactStub
	fakeReturns := fake.validateArtifactReturns
	fake.recordInvocation("ValidateArtifact", []interface{}{arg1})
	fake.validateArtifactMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeArtifactService) ValidateArtifactCallCount() int {
	fake.validateArtifactMutex.RLock()
	defer fake.validateArtifactMutex.RUnlock()
	return len(fake.validateArtifactArgsForCall)
}

func (fake *FakeArtifactService) ValidateArtifactCalls(stub func(types.Artifact) error) {
	fake.validateArtifactMutex.Lock()
	defer fake.validateArtifactMutex.Unlock()
	fake.ValidateArtifactStub = stub
}

func (fake *FakeArtifactService) ValidateArtifactArgsForCall(i int) types.Artifact {
	fake.validateArtifactMutex.RLock()
	defer fake.validateArtifactMutex.RUnlock()
	argsForCall := fake.validateArtifactArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeArtifactService) ValidateArtifactReturns(result1 error) {
	fake.validateArtifactMutex.Lock()
	defer fake.validateArtifactMutex.Unlock()
	fake.ValidateArtifactStub = nil
	fake.validateArtifactReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifactService) ValidateArtifactReturnsOnCall(i int, result1 error) {
	fake.validateArtifactMutex.Lock()
	defer fake.validateArtifactMutex.Unlock()
	fake.ValidateArtifactStub = nil
	if fake.validateArtifactReturnsOnCall == nil {
		fake.validateArtifactReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateArtifactReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifactService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addArtifactToTaskMutex.RLock()
	defer fake.addArtifactToTaskMutex.RUnlock()
	fake.addArtifactsToTaskMutex.RLock()
	defer fake.addArtifactsToTaskMutex.RUnlock()
	fake.cleanupExpiredArtifactsMutex.RLock()
	defer fake.cleanupExpiredArtifactsMutex.RUnlock()
	fake.cleanupOldestArtifactsMutex.RLock()
	defer fake.cleanupOldestArtifactsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createDataArtifactMutex.RLock()
	defer fake.createDataArtifactMutex.RUnlock()
	fake.createFileArtifactMutex.RLock()
	defer fake.createFileArtifactMutex.RUnlock()
	fake.createFileArtifactFromURIMutex.RLock()
	defer fake.createFileArtifactFromURIMutex.RUnlock()
	fake.createMultiPartArtifactMutex.RLock()
	defer fake.createMultiPartArtifactMutex.RUnlock()
	fake.createTaskArtifactUpdateEventMutex.RLock()
	defer fake.createTaskArtifactUpdateEventMutex.RUnlock()
	fake.createTextArtifactMutex.RLock()
	defer fake.createTextArtifactMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.getArtifactByIDMutex.RLock()
	defer fake.getArtifactByIDMutex.RUnlock()
	fake.getArtifactsByTypeMutex.RLock()
	defer fake.getArtifactsByTypeMutex.RUnlock()
	fake.getMimeTypeFromExtensionMutex.RLock()
	defer fake.getMimeTypeFromExtensionMutex.RUnlock()
	fake.retrieveMutex.RLock()
	defer fake.retrieveMutex.RUnlock()
	fake.validateArtifactMutex.RLock()
	defer fake.validateArtifactMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeArtifactService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.ArtifactService = new(FakeArtifactService)
