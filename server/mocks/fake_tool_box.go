// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/inference-gateway/adk/server"
	"github.com/inference-gateway/sdk"
)

type FakeToolBox struct {
	ExecuteToolStub        func(context.Context, string, map[string]any) (string, error)
	executeToolMutex       sync.RWMutex
	executeToolArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]any
	}
	executeToolReturns struct {
		result1 string
		result2 error
	}
	executeToolReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetToolStub        func(string) (server.Tool, bool)
	getToolMutex       sync.RWMutex
	getToolArgsForCall []struct {
		arg1 string
	}
	getToolReturns struct {
		result1 server.Tool
		result2 bool
	}
	getToolReturnsOnCall map[int]struct {
		result1 server.Tool
		result2 bool
	}
	GetToolNamesStub        func() []string
	getToolNamesMutex       sync.RWMutex
	getToolNamesArgsForCall []struct {
	}
	getToolNamesReturns struct {
		result1 []string
	}
	getToolNamesReturnsOnCall map[int]struct {
		result1 []string
	}
	GetToolsStub        func() []sdk.ChatCompletionTool
	getToolsMutex       sync.RWMutex
	getToolsArgsForCall []struct {
	}
	getToolsReturns struct {
		result1 []sdk.ChatCompletionTool
	}
	getToolsReturnsOnCall map[int]struct {
		result1 []sdk.ChatCompletionTool
	}
	HasToolStub        func(string) bool
	hasToolMutex       sync.RWMutex
	hasToolArgsForCall []struct {
		arg1 string
	}
	hasToolReturns struct {
		result1 bool
	}
	hasToolReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeToolBox) ExecuteTool(arg1 context.Context, arg2 string, arg3 map[string]any) (string, error) {
	fake.executeToolMutex.Lock()
	ret, specificReturn := fake.executeToolReturnsOnCall[len(fake.executeToolArgsForCall)]
	fake.executeToolArgsForCall = append(fake.executeToolArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]any
	}{arg1, arg2, arg3})
	stub := fake.ExecuteToolStub
	fakeReturns := fake.executeToolReturns
	fake.recordInvocation("ExecuteTool", []interface{}{arg1, arg2, arg3})
	fake.executeToolMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolBox) ExecuteToolCallCount() int {
	fake.executeToolMutex.RLock()
	defer fake.executeToolMutex.RUnlock()
	return len(fake.executeToolArgsForCall)
}

func (fake *FakeToolBox) ExecuteToolCalls(stub func(context.Context, string, map[string]any) (string, error)) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = stub
}

func (fake *FakeToolBox) ExecuteToolArgsForCall(i int) (context.Context, string, map[string]any) {
	fake.executeToolMutex.RLock()
	defer fake.executeToolMutex.RUnlock()
	argsForCall := fake.executeToolArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeToolBox) ExecuteToolReturns(result1 string, result2 error) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = nil
	fake.executeToolReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeToolBox) ExecuteToolReturnsOnCall(i int, result1 string, result2 error) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = nil
	if fake.executeToolReturnsOnCall == nil {
		fake.executeToolReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.executeToolReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeToolBox) GetTool(arg1 string) (server.Tool, bool) {
	fake.getToolMutex.Lock()
	ret, specificReturn := fake.getToolReturnsOnCall[len(fake.getToolArgsForCall)]
	fake.getToolArgsForCall = append(fake.getToolArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetToolStub
	fakeReturns := fake.getToolReturns
	fake.recordInvocation("GetTool", []interface{}{arg1})
	fake.getToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolBox) GetToolCallCount() int {
	fake.getToolMutex.RLock()
	defer fake.getToolMutex.RUnlock()
	return len(fake.getToolArgsForCall)
}

func (fake *FakeToolBox) GetToolCalls(stub func(string) (server.Tool, bool)) {
	fake.getToolMutex.Lock()
	defer fake.getToolMutex.Unlock()
	fake.GetToolStub = stub
}

func (fake *FakeToolBox) GetToolArgsForCall(i int) string {
	fake.getToolMutex.RLock()
	defer fake.getToolMutex.RUnlock()
	argsForCall := fake.getToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolBox) GetToolReturns(result1 server.Tool, result2 bool) {
	fake.getToolMutex.Lock()
	defer fake.getToolMutex.Unlock()
	fake.GetToolStub = nil
	fake.getToolReturns = struct {
		result1 server.Tool
		result2 bool
	}{result1, result2}
}

func (fake *FakeToolBox) GetToolReturnsOnCall(i int, result1 server.Tool, result2 bool) {
	fake.getToolMutex.Lock()
	defer fake.getToolMutex.Unlock()
	fake.GetToolStub = nil
	if fake.getToolReturnsOnCall == nil {
		fake.getToolReturnsOnCall = make(map[int]struct {
			result1 server.Tool
			result2 bool
		})
	}
	fake.getToolReturnsOnCall[i] = struct {
		result1 server.Tool
		result2 bool
	}{result1, result2}
}

func (fake *FakeToolBox) GetToolNames() []string {
	fake.getToolNamesMutex.Lock()
	ret, specificReturn := fake.getToolNamesReturnsOnCall[len(fake.getToolNamesArgsForCall)]
	fake.getToolNamesArgsForCall = append(fake.getToolNamesArgsForCall, struct {
	}{})
	stub := fake.GetToolNamesStub
	fakeReturns := fake.getToolNamesReturns
	fake.recordInvocation("GetToolNames", []interface{}{})
	fake.getToolNamesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolBox) GetToolNamesCallCount() int {
	fake.getToolNamesMutex.RLock()
	defer fake.getToolNamesMutex.RUnlock()
	return len(fake.getToolNamesArgsForCall)
}

func (fake *FakeToolBox) GetToolNamesCalls(stub func() []string) {
	fake.getToolNamesMutex.Lock()
	defer fake.getToolNamesMutex.Unlock()
	fake.GetToolNamesStub = stub
}

func (fake *FakeToolBox) GetToolNamesReturns(result1 []string) {
	fake.getToolNamesMutex.Lock()
	defer fake.getToolNamesMutex.Unlock()
	fake.GetToolNamesStub = nil
	fake.getToolNamesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeToolBox) GetToolNamesReturnsOnCall(i int, result1 []string) {
	fake.getToolNamesMutex.Lock()
	defer fake.getToolNamesMutex.Unlock()
	fake.GetToolNamesStub = nil
	if fake.getToolNamesReturnsOnCall == nil {
		fake.getToolNamesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getToolNamesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeToolBox) GetTools() []sdk.ChatCompletionTool {
	fake.getToolsMutex.Lock()
	ret, specificReturn := fake.getToolsReturnsOnCall[len(fake.getToolsArgsForCall)]
	fake.getToolsArgsForCall = append(fake.getToolsArgsForCall, struct {
	}{})
	stub := fake.GetToolsStub
	fakeReturns := fake.getToolsReturns
	fake.recordInvocation("GetTools", []interface{}{})
	fake.getToolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolBox) GetToolsCallCount() int {
	fake.getToolsMutex.RLock()
	defer fake.getToolsMutex.RUnlock()
	return len(fake.getToolsArgsForCall)
}

func (fake *FakeToolBox) GetToolsCalls(stub func() []sdk.ChatCompletionTool) {
	fake.getToolsMutex.Lock()
	defer fake.getToolsMutex.Unlock()
	fake.GetToolsStub = stub
}

func (fake *FakeToolBox) GetToolsReturns(result1 []sdk.ChatCompletionTool) {
	fake.getToolsMutex.Lock()
	defer fake.getToolsMutex.Unlock()
	fake.GetToolsStub = nil
	fake.getToolsReturns = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolBox) GetToolsReturnsOnCall(i int, result1 []sdk.ChatCompletionTool) {
	fake.getToolsMutex.Lock()
	defer fake.getToolsMutex.Unlock()
	fake.GetToolsStub = nil
	if fake.getToolsReturnsOnCall == nil {
		fake.getToolsReturnsOnCall = make(map[int]struct {
			result1 []sdk.ChatCompletionTool
		})
	}
	fake.getToolsReturnsOnCall[i] = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolBox) HasTool(arg1 string) bool {
	fake.hasToolMutex.Lock()
	ret, specificReturn := fake.hasToolReturnsOnCall[len(fake.hasToolArgsForCall)]
	fake.hasToolArgsForCall = append(fake.hasToolArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.HasToolStub
	fakeReturns := fake.hasToolReturns
	fake.recordInvocation("HasTool", []interface{}{arg1})
	fake.hasToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolBox) HasToolCallCount() int {
	fake.hasToolMutex.RLock()
	defer fake.hasToolMutex.RUnlock()
	return len(fake.hasToolArgsForCall)
}

func (fake *FakeToolBox) HasToolCalls(stub func(string) bool) {
	fake.hasToolMutex.Lock()
	defer fake.hasToolMutex.Unlock()
	fake.HasToolStub = stub
}

func (fake *FakeToolBox) HasToolArgsForCall(i int) string {
	fake.hasToolMutex.RLock()
	defer fake.hasToolMutex.RUnlock()
	argsForCall := fake.hasToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolBox) HasToolReturns(result1 bool) {
	fake.hasToolMutex.Lock()
	defer fake.hasToolMutex.Unlock()
	fake.HasToolStub = nil
	fake.hasToolReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeToolBox) HasToolReturnsOnCall(i int, result1 bool) {
	fake.hasToolMutex.Lock()
	defer fake.hasToolMutex.Unlock()
	fake.HasToolStub = nil
	if fake.hasToolReturnsOnCall == nil {
		fake.hasToolReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasToolReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeToolBox) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.executeToolMutex.RLock()
	defer fake.executeToolMutex.RUnlock()
	fake.getToolMutex.RLock()
	defer fake.getToolMutex.RUnlock()
	fake.getToolNamesMutex.RLock()
	defer fake.getToolNamesMutex.RUnlock()
	fake.getToolsMutex.RLock()
	defer fake.getToolsMutex.RUnlock()
	fake.hasToolMutex.RLock()
	defer fake.hasToolMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeToolBox) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.ToolBox = new(FakeToolBox)
