// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/inference-gateway/adk/server"
	"github.com/inference-gateway/adk/types"
)

type FakeStorage struct {
	AddMessageToConversationStub        func(string, types.Message) error
	addMessageToConversationMutex       sync.RWMutex
	addMessageToConversationArgsForCall []struct {
		arg1 string
		arg2 types.Message
	}
	addMessageToConversationReturns struct {
		result1 error
	}
	addMessageToConversationReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupCompletedTasksStub        func() int
	cleanupCompletedTasksMutex       sync.RWMutex
	cleanupCompletedTasksArgsForCall []struct {
	}
	cleanupCompletedTasksReturns struct {
		result1 int
	}
	cleanupCompletedTasksReturnsOnCall map[int]struct {
		result1 int
	}
	CleanupOldConversationsStub        func(int64) int
	cleanupOldConversationsMutex       sync.RWMutex
	cleanupOldConversationsArgsForCall []struct {
		arg1 int64
	}
	cleanupOldConversationsReturns struct {
		result1 int
	}
	cleanupOldConversationsReturnsOnCall map[int]struct {
		result1 int
	}
	DeleteContextStub        func(string) error
	deleteContextMutex       sync.RWMutex
	deleteContextArgsForCall []struct {
		arg1 string
	}
	deleteContextReturns struct {
		result1 error
	}
	deleteContextReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteContextAndTasksStub        func(string) error
	deleteContextAndTasksMutex       sync.RWMutex
	deleteContextAndTasksArgsForCall []struct {
		arg1 string
	}
	deleteContextAndTasksReturns struct {
		result1 error
	}
	deleteContextAndTasksReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	GetContextsStub        func() []string
	getContextsMutex       sync.RWMutex
	getContextsArgsForCall []struct {
	}
	getContextsReturns struct {
		result1 []string
	}
	getContextsReturnsOnCall map[int]struct {
		result1 []string
	}
	GetContextsWithTasksStub        func() []string
	getContextsWithTasksMutex       sync.RWMutex
	getContextsWithTasksArgsForCall []struct {
	}
	getContextsWithTasksReturns struct {
		result1 []string
	}
	getContextsWithTasksReturnsOnCall map[int]struct {
		result1 []string
	}
	GetConversationHistoryStub        func(string) []types.Message
	getConversationHistoryMutex       sync.RWMutex
	getConversationHistoryArgsForCall []struct {
		arg1 string
	}
	getConversationHistoryReturns struct {
		result1 []types.Message
	}
	getConversationHistoryReturnsOnCall map[int]struct {
		result1 []types.Message
	}
	GetStatsStub        func() server.StorageStats
	getStatsMutex       sync.RWMutex
	getStatsArgsForCall []struct {
	}
	getStatsReturns struct {
		result1 server.StorageStats
	}
	getStatsReturnsOnCall map[int]struct {
		result1 server.StorageStats
	}
	GetTaskStub        func(string) (*types.Task, bool)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 string
	}
	getTaskReturns struct {
		result1 *types.Task
		result2 bool
	}
	getTaskReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 bool
	}
	GetTaskByContextAndIDStub        func(string, string) (*types.Task, bool)
	getTaskByContextAndIDMutex       sync.RWMutex
	getTaskByContextAndIDArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getTaskByContextAndIDReturns struct {
		result1 *types.Task
		result2 bool
	}
	getTaskByContextAndIDReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 bool
	}
	ListTasksStub        func(server.TaskFilter) ([]*types.Task, error)
	listTasksMutex       sync.RWMutex
	listTasksArgsForCall []struct {
		arg1 server.TaskFilter
	}
	listTasksReturns struct {
		result1 []*types.Task
		result2 error
	}
	listTasksReturnsOnCall map[int]struct {
		result1 []*types.Task
		result2 error
	}
	ListTasksByContextStub        func(string, server.TaskFilter) ([]*types.Task, error)
	listTasksByContextMutex       sync.RWMutex
	listTasksByContextArgsForCall []struct {
		arg1 string
		arg2 server.TaskFilter
	}
	listTasksByContextReturns struct {
		result1 []*types.Task
		result2 error
	}
	listTasksByContextReturnsOnCall map[int]struct {
		result1 []*types.Task
		result2 error
	}
	StoreTaskStub        func(*types.Task) error
	storeTaskMutex       sync.RWMutex
	storeTaskArgsForCall []struct {
		arg1 *types.Task
	}
	storeTaskReturns struct {
		result1 error
	}
	storeTaskReturnsOnCall map[int]struct {
		result1 error
	}
	TrimConversationHistoryStub        func(string, int) error
	trimConversationHistoryMutex       sync.RWMutex
	trimConversationHistoryArgsForCall []struct {
		arg1 string
		arg2 int
	}
	trimConversationHistoryReturns struct {
		result1 error
	}
	trimConversationHistoryReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateConversationHistoryStub        func(string, []types.Message)
	updateConversationHistoryMutex       sync.RWMutex
	updateConversationHistoryArgsForCall []struct {
		arg1 string
		arg2 []types.Message
	}
	UpdateTaskStub        func(*types.Task) error
	updateTaskMutex       sync.RWMutex
	updateTaskArgsForCall []struct {
		arg1 *types.Task
	}
	updateTaskReturns struct {
		result1 error
	}
	updateTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) AddMessageToConversation(arg1 string, arg2 types.Message) error {
	fake.addMessageToConversationMutex.Lock()
	ret, specificReturn := fake.addMessageToConversationReturnsOnCall[len(fake.addMessageToConversationArgsForCall)]
	fake.addMessageToConversationArgsForCall = append(fake.addMessageToConversationArgsForCall, struct {
		arg1 string
		arg2 types.Message
	}{arg1, arg2})
	stub := fake.AddMessageToConversationStub
	fakeReturns := fake.addMessageToConversationReturns
	fake.recordInvocation("AddMessageToConversation", []interface{}{arg1, arg2})
	fake.addMessageToConversationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) AddMessageToConversationCallCount() int {
	fake.addMessageToConversationMutex.RLock()
	defer fake.addMessageToConversationMutex.RUnlock()
	return len(fake.addMessageToConversationArgsForCall)
}

func (fake *FakeStorage) AddMessageToConversationCalls(stub func(string, types.Message) error) {
	fake.addMessageToConversationMutex.Lock()
	defer fake.addMessageToConversationMutex.Unlock()
	fake.AddMessageToConversationStub = stub
}

func (fake *FakeStorage) AddMessageToConversationArgsForCall(i int) (string, types.Message) {
	fake.addMessageToConversationMutex.RLock()
	defer fake.addMessageToConversationMutex.RUnlock()
	argsForCall := fake.addMessageToConversationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) AddMessageToConversationReturns(result1 error) {
	fake.addMessageToConversationMutex.Lock()
	defer fake.addMessageToConversationMutex.Unlock()
	fake.AddMessageToConversationStub = nil
	fake.addMessageToConversationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) AddMessageToConversationReturnsOnCall(i int, result1 error) {
	fake.addMessageToConversationMutex.Lock()
	defer fake.addMessageToConversationMutex.Unlock()
	fake.AddMessageToConversationStub = nil
	if fake.addMessageToConversationReturnsOnCall == nil {
		fake.addMessageToConversationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addMessageToConversationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) CleanupCompletedTasks() int {
	fake.cleanupCompletedTasksMutex.Lock()
	ret, specificReturn := fake.cleanupCompletedTasksReturnsOnCall[len(fake.cleanupCompletedTasksArgsForCall)]
	fake.cleanupCompletedTasksArgsForCall = append(fake.cleanupCompletedTasksArgsForCall, struct {
	}{})
	stub := fake.CleanupCompletedTasksStub
	fakeReturns := fake.cleanupCompletedTasksReturns
	fake.recordInvocation("CleanupCompletedTasks", []interface{}{})
	fake.cleanupCompletedTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) CleanupCompletedTasksCallCount() int {
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	return len(fake.cleanupCompletedTasksArgsForCall)
}

func (fake *FakeStorage) CleanupCompletedTasksCalls(stub func() int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = stub
}

func (fake *FakeStorage) CleanupCompletedTasksReturns(result1 int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = nil
	fake.cleanupCompletedTasksReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupCompletedTasksReturnsOnCall(i int, result1 int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = nil
	if fake.cleanupCompletedTasksReturnsOnCall == nil {
		fake.cleanupCompletedTasksReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cleanupCompletedTasksReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupOldConversations(arg1 int64) int {
	fake.cleanupOldConversationsMutex.Lock()
	ret, specificReturn := fake.cleanupOldConversationsReturnsOnCall[len(fake.cleanupOldConversationsArgsForCall)]
	fake.cleanupOldConversationsArgsForCall = append(fake.cleanupOldConversationsArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.CleanupOldConversationsStub
	fakeReturns := fake.cleanupOldConversationsReturns
	fake.recordInvocation("CleanupOldConversations", []interface{}{arg1})
	fake.cleanupOldConversationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) CleanupOldConversationsCallCount() int {
	fake.cleanupOldConversationsMutex.RLock()
	defer fake.cleanupOldConversationsMutex.RUnlock()
	return len(fake.cleanupOldConversationsArgsForCall)
}

func (fake *FakeStorage) CleanupOldConversationsCalls(stub func(int64) int) {
	fake.cleanupOldConversationsMutex.Lock()
	defer fake.cleanupOldConversationsMutex.Unlock()
	fake.CleanupOldConversationsStub = stub
}

func (fake *FakeStorage) CleanupOldConversationsArgsForCall(i int) int64 {
	fake.cleanupOldConversationsMutex.RLock()
	defer fake.cleanupOldConversationsMutex.RUnlock()
	argsForCall := fake.cleanupOldConversationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) CleanupOldConversationsReturns(result1 int) {
	fake.cleanupOldConversationsMutex.Lock()
	defer fake.cleanupOldConversationsMutex.Unlock()
	fake.CleanupOldConversationsStub = nil
	fake.cleanupOldConversationsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupOldConversationsReturnsOnCall(i int, result1 int) {
	fake.cleanupOldConversationsMutex.Lock()
	defer fake.cleanupOldConversationsMutex.Unlock()
	fake.CleanupOldConversationsStub = nil
	if fake.cleanupOldConversationsReturnsOnCall == nil {
		fake.cleanupOldConversationsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cleanupOldConversationsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) DeleteContext(arg1 string) error {
	fake.deleteContextMutex.Lock()
	ret, specificReturn := fake.deleteContextReturnsOnCall[len(fake.deleteContextArgsForCall)]
	fake.deleteContextArgsForCall = append(fake.deleteContextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteContextStub
	fakeReturns := fake.deleteContextReturns
	fake.recordInvocation("DeleteContext", []interface{}{arg1})
	fake.deleteContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteContextCallCount() int {
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	return len(fake.deleteContextArgsForCall)
}

func (fake *FakeStorage) DeleteContextCalls(stub func(string) error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = stub
}

func (fake *FakeStorage) DeleteContextArgsForCall(i int) string {
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	argsForCall := fake.deleteContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteContextReturns(result1 error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = nil
	fake.deleteContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextReturnsOnCall(i int, result1 error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = nil
	if fake.deleteContextReturnsOnCall == nil {
		fake.deleteContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextAndTasks(arg1 string) error {
	fake.deleteContextAndTasksMutex.Lock()
	ret, specificReturn := fake.deleteContextAndTasksReturnsOnCall[len(fake.deleteContextAndTasksArgsForCall)]
	fake.deleteContextAndTasksArgsForCall = append(fake.deleteContextAndTasksArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteContextAndTasksStub
	fakeReturns := fake.deleteContextAndTasksReturns
	fake.recordInvocation("DeleteContextAndTasks", []interface{}{arg1})
	fake.deleteContextAndTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteContextAndTasksCallCount() int {
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	return len(fake.deleteContextAndTasksArgsForCall)
}

func (fake *FakeStorage) DeleteContextAndTasksCalls(stub func(string) error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = stub
}

func (fake *FakeStorage) DeleteContextAndTasksArgsForCall(i int) string {
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	argsForCall := fake.deleteContextAndTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteContextAndTasksReturns(result1 error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = nil
	fake.deleteContextAndTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextAndTasksReturnsOnCall(i int, result1 error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = nil
	if fake.deleteContextAndTasksReturnsOnCall == nil {
		fake.deleteContextAndTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContextAndTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteTask(arg1 string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteTaskStub
	fakeReturns := fake.deleteTaskReturns
	fake.recordInvocation("DeleteTask", []interface{}{arg1})
	fake.deleteTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeStorage) DeleteTaskCalls(stub func(string) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeStorage) DeleteTaskArgsForCall(i int) string {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) GetContexts() []string {
	fake.getContextsMutex.Lock()
	ret, specificReturn := fake.getContextsReturnsOnCall[len(fake.getContextsArgsForCall)]
	fake.getContextsArgsForCall = append(fake.getContextsArgsForCall, struct {
	}{})
	stub := fake.GetContextsStub
	fakeReturns := fake.getContextsReturns
	fake.recordInvocation("GetContexts", []interface{}{})
	fake.getContextsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetContextsCallCount() int {
	fake.getContextsMutex.RLock()
	defer fake.getContextsMutex.RUnlock()
	return len(fake.getContextsArgsForCall)
}

func (fake *FakeStorage) GetContextsCalls(stub func() []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = stub
}

func (fake *FakeStorage) GetContextsReturns(result1 []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = nil
	fake.getContextsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsReturnsOnCall(i int, result1 []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = nil
	if fake.getContextsReturnsOnCall == nil {
		fake.getContextsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getContextsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsWithTasks() []string {
	fake.getContextsWithTasksMutex.Lock()
	ret, specificReturn := fake.getContextsWithTasksReturnsOnCall[len(fake.getContextsWithTasksArgsForCall)]
	fake.getContextsWithTasksArgsForCall = append(fake.getContextsWithTasksArgsForCall, struct {
	}{})
	stub := fake.GetContextsWithTasksStub
	fakeReturns := fake.getContextsWithTasksReturns
	fake.recordInvocation("GetContextsWithTasks", []interface{}{})
	fake.getContextsWithTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetContextsWithTasksCallCount() int {
	fake.getContextsWithTasksMutex.RLock()
	defer fake.getContextsWithTasksMutex.RUnlock()
	return len(fake.getContextsWithTasksArgsForCall)
}

func (fake *FakeStorage) GetContextsWithTasksCalls(stub func() []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = stub
}

func (fake *FakeStorage) GetContextsWithTasksReturns(result1 []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = nil
	fake.getContextsWithTasksReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsWithTasksReturnsOnCall(i int, result1 []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = nil
	if fake.getContextsWithTasksReturnsOnCall == nil {
		fake.getContextsWithTasksReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getContextsWithTasksReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetConversationHistory(arg1 string) []types.Message {
	fake.getConversationHistoryMutex.Lock()
	ret, specificReturn := fake.getConversationHistoryReturnsOnCall[len(fake.getConversationHistoryArgsForCall)]
	fake.getConversationHistoryArgsForCall = append(fake.getConversationHistoryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetConversationHistoryStub
	fakeReturns := fake.getConversationHistoryReturns
	fake.recordInvocation("GetConversationHistory", []interface{}{arg1})
	fake.getConversationHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetConversationHistoryCallCount() int {
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	return len(fake.getConversationHistoryArgsForCall)
}

func (fake *FakeStorage) GetConversationHistoryCalls(stub func(string) []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = stub
}

func (fake *FakeStorage) GetConversationHistoryArgsForCall(i int) string {
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	argsForCall := fake.getConversationHistoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) GetConversationHistoryReturns(result1 []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = nil
	fake.getConversationHistoryReturns = struct {
		result1 []types.Message
	}{result1}
}

func (fake *FakeStorage) GetConversationHistoryReturnsOnCall(i int, result1 []types.Message) {
	fake.getConversationHistoryMutex.Lock()
	defer fake.getConversationHistoryMutex.Unlock()
	fake.GetConversationHistoryStub = nil
	if fake.getConversationHistoryReturnsOnCall == nil {
		fake.getConversationHistoryReturnsOnCall = make(map[int]struct {
			result1 []types.Message
		})
	}
	fake.getConversationHistoryReturnsOnCall[i] = struct {
		result1 []types.Message
	}{result1}
}

func (fake *FakeStorage) GetStats() server.StorageStats {
	fake.getStatsMutex.Lock()
	ret, specificReturn := fake.getStatsReturnsOnCall[len(fake.getStatsArgsForCall)]
	fake.getStatsArgsForCall = append(fake.getStatsArgsForCall, struct {
	}{})
	stub := fake.GetStatsStub
	fakeReturns := fake.getStatsReturns
	fake.recordInvocation("GetStats", []interface{}{})
	fake.getStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetStatsCallCount() int {
	fake.getStatsMutex.RLock()
	defer fake.getStatsMutex.RUnlock()
	return len(fake.getStatsArgsForCall)
}

func (fake *FakeStorage) GetStatsCalls(stub func() server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = stub
}

func (fake *FakeStorage) GetStatsReturns(result1 server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = nil
	fake.getStatsReturns = struct {
		result1 server.StorageStats
	}{result1}
}

func (fake *FakeStorage) GetStatsReturnsOnCall(i int, result1 server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = nil
	if fake.getStatsReturnsOnCall == nil {
		fake.getStatsReturnsOnCall = make(map[int]struct {
			result1 server.StorageStats
		})
	}
	fake.getStatsReturnsOnCall[i] = struct {
		result1 server.StorageStats
	}{result1}
}

func (fake *FakeStorage) GetTask(arg1 string) (*types.Task, bool) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeStorage) GetTaskCalls(stub func(string) (*types.Task, bool)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeStorage) GetTaskArgsForCall(i int) string {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) GetTaskReturns(result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskReturnsOnCall(i int, result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 bool
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskByContextAndID(arg1 string, arg2 string) (*types.Task, bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	ret, specificReturn := fake.getTaskByContextAndIDReturnsOnCall[len(fake.getTaskByContextAndIDArgsForCall)]
	fake.getTaskByContextAndIDArgsForCall = append(fake.getTaskByContextAndIDArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTaskByContextAndIDStub
	fakeReturns := fake.getTaskByContextAndIDReturns
	fake.recordInvocation("GetTaskByContextAndID", []interface{}{arg1, arg2})
	fake.getTaskByContextAndIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetTaskByContextAndIDCallCount() int {
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	return len(fake.getTaskByContextAndIDArgsForCall)
}

func (fake *FakeStorage) GetTaskByContextAndIDCalls(stub func(string, string) (*types.Task, bool)) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = stub
}

func (fake *FakeStorage) GetTaskByContextAndIDArgsForCall(i int) (string, string) {
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	argsForCall := fake.getTaskByContextAndIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetTaskByContextAndIDReturns(result1 *types.Task, result2 bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = nil
	fake.getTaskByContextAndIDReturns = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskByContextAndIDReturnsOnCall(i int, result1 *types.Task, result2 bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = nil
	if fake.getTaskByContextAndIDReturnsOnCall == nil {
		fake.getTaskByContextAndIDReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 bool
		})
	}
	fake.getTaskByContextAndIDReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) ListTasks(arg1 server.TaskFilter) ([]*types.Task, error) {
	fake.listTasksMutex.Lock()
	ret, specificReturn := fake.listTasksReturnsOnCall[len(fake.listTasksArgsForCall)]
	fake.listTasksArgsForCall = append(fake.listTasksArgsForCall, struct {
		arg1 server.TaskFilter
	}{arg1})
	stub := fake.ListTasksStub
	fakeReturns := fake.listTasksReturns
	fake.recordInvocation("ListTasks", []interface{}{arg1})
	fake.listTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ListTasksCallCount() int {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	return len(fake.listTasksArgsForCall)
}

func (fake *FakeStorage) ListTasksCalls(stub func(server.TaskFilter) ([]*types.Task, error)) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = stub
}

func (fake *FakeStorage) ListTasksArgsForCall(i int) server.TaskFilter {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	argsForCall := fake.listTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) ListTasksReturns(result1 []*types.Task, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	fake.listTasksReturns = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksReturnsOnCall(i int, result1 []*types.Task, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	if fake.listTasksReturnsOnCall == nil {
		fake.listTasksReturnsOnCall = make(map[int]struct {
			result1 []*types.Task
			result2 error
		})
	}
	fake.listTasksReturnsOnCall[i] = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksByContext(arg1 string, arg2 server.TaskFilter) ([]*types.Task, error) {
	fake.listTasksByContextMutex.Lock()
	ret, specificReturn := fake.listTasksByContextReturnsOnCall[len(fake.listTasksByContextArgsForCall)]
	fake.listTasksByContextArgsForCall = append(fake.listTasksByContextArgsForCall, struct {
		arg1 string
		arg2 server.TaskFilter
	}{arg1, arg2})
	stub := fake.ListTasksByContextStub
	fakeReturns := fake.listTasksByContextReturns
	fake.recordInvocation("ListTasksByContext", []interface{}{arg1, arg2})
	fake.listTasksByContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ListTasksByContextCallCount() int {
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	return len(fake.listTasksByContextArgsForCall)
}

func (fake *FakeStorage) ListTasksByContextCalls(stub func(string, server.TaskFilter) ([]*types.Task, error)) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = stub
}

func (fake *FakeStorage) ListTasksByContextArgsForCall(i int) (string, server.TaskFilter) {
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	argsForCall := fake.listTasksByContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) ListTasksByContextReturns(result1 []*types.Task, result2 error) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = nil
	fake.listTasksByContextReturns = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksByContextReturnsOnCall(i int, result1 []*types.Task, result2 error) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = nil
	if fake.listTasksByContextReturnsOnCall == nil {
		fake.listTasksByContextReturnsOnCall = make(map[int]struct {
			result1 []*types.Task
			result2 error
		})
	}
	fake.listTasksByContextReturnsOnCall[i] = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) StoreTask(arg1 *types.Task) error {
	fake.storeTaskMutex.Lock()
	ret, specificReturn := fake.storeTaskReturnsOnCall[len(fake.storeTaskArgsForCall)]
	fake.storeTaskArgsForCall = append(fake.storeTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.StoreTaskStub
	fakeReturns := fake.storeTaskReturns
	fake.recordInvocation("StoreTask", []interface{}{arg1})
	fake.storeTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) StoreTaskCallCount() int {
	fake.storeTaskMutex.RLock()
	defer fake.storeTaskMutex.RUnlock()
	return len(fake.storeTaskArgsForCall)
}

func (fake *FakeStorage) StoreTaskCalls(stub func(*types.Task) error) {
	fake.storeTaskMutex.Lock()
	defer fake.storeTaskMutex.Unlock()
	fake.StoreTaskStub = stub
}

func (fake *FakeStorage) StoreTaskArgsForCall(i int) *types.Task {
	fake.storeTaskMutex.RLock()
	defer fake.storeTaskMutex.RUnlock()
	argsForCall := fake.storeTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) StoreTaskReturns(result1 error) {
	fake.storeTaskMutex.Lock()
	defer fake.storeTaskMutex.Unlock()
	fake.StoreTaskStub = nil
	fake.storeTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) StoreTaskReturnsOnCall(i int, result1 error) {
	fake.storeTaskMutex.Lock()
	defer fake.storeTaskMutex.Unlock()
	fake.StoreTaskStub = nil
	if fake.storeTaskReturnsOnCall == nil {
		fake.storeTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) TrimConversationHistory(arg1 string, arg2 int) error {
	fake.trimConversationHistoryMutex.Lock()
	ret, specificReturn := fake.trimConversationHistoryReturnsOnCall[len(fake.trimConversationHistoryArgsForCall)]
	fake.trimConversationHistoryArgsForCall = append(fake.trimConversationHistoryArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.TrimConversationHistoryStub
	fakeReturns := fake.trimConversationHistoryReturns
	fake.recordInvocation("TrimConversationHistory", []interface{}{arg1, arg2})
	fake.trimConversationHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) TrimConversationHistoryCallCount() int {
	fake.trimConversationHistoryMutex.RLock()
	defer fake.trimConversationHistoryMutex.RUnlock()
	return len(fake.trimConversationHistoryArgsForCall)
}

func (fake *FakeStorage) TrimConversationHistoryCalls(stub func(string, int) error) {
	fake.trimConversationHistoryMutex.Lock()
	defer fake.trimConversationHistoryMutex.Unlock()
	fake.TrimConversationHistoryStub = stub
}

func (fake *FakeStorage) TrimConversationHistoryArgsForCall(i int) (string, int) {
	fake.trimConversationHistoryMutex.RLock()
	defer fake.trimConversationHistoryMutex.RUnlock()
	argsForCall := fake.trimConversationHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TrimConversationHistoryReturns(result1 error) {
	fake.trimConversationHistoryMutex.Lock()
	defer fake.trimConversationHistoryMutex.Unlock()
	fake.TrimConversationHistoryStub = nil
	fake.trimConversationHistoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) TrimConversationHistoryReturnsOnCall(i int, result1 error) {
	fake.trimConversationHistoryMutex.Lock()
	defer fake.trimConversationHistoryMutex.Unlock()
	fake.TrimConversationHistoryStub = nil
	if fake.trimConversationHistoryReturnsOnCall == nil {
		fake.trimConversationHistoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.trimConversationHistoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) UpdateConversationHistory(arg1 string, arg2 []types.Message) {
	var arg2Copy []types.Message
	if arg2 != nil {
		arg2Copy = make([]types.Message, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateConversationHistoryMutex.Lock()
	fake.updateConversationHistoryArgsForCall = append(fake.updateConversationHistoryArgsForCall, struct {
		arg1 string
		arg2 []types.Message
	}{arg1, arg2Copy})
	stub := fake.UpdateConversationHistoryStub
	fake.recordInvocation("UpdateConversationHistory", []interface{}{arg1, arg2Copy})
	fake.updateConversationHistoryMutex.Unlock()
	if stub != nil {
		fake.UpdateConversationHistoryStub(arg1, arg2)
	}
}

func (fake *FakeStorage) UpdateConversationHistoryCallCount() int {
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	return len(fake.updateConversationHistoryArgsForCall)
}

func (fake *FakeStorage) UpdateConversationHistoryCalls(stub func(string, []types.Message)) {
	fake.updateConversationHistoryMutex.Lock()
	defer fake.updateConversationHistoryMutex.Unlock()
	fake.UpdateConversationHistoryStub = stub
}

func (fake *FakeStorage) UpdateConversationHistoryArgsForCall(i int) (string, []types.Message) {
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	argsForCall := fake.updateConversationHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) UpdateTask(arg1 *types.Task) error {
	fake.updateTaskMutex.Lock()
	ret, specificReturn := fake.updateTaskReturnsOnCall[len(fake.updateTaskArgsForCall)]
	fake.updateTaskArgsForCall = append(fake.updateTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.UpdateTaskStub
	fakeReturns := fake.updateTaskReturns
	fake.recordInvocation("UpdateTask", []interface{}{arg1})
	fake.updateTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) UpdateTaskCallCount() int {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	return len(fake.updateTaskArgsForCall)
}

func (fake *FakeStorage) UpdateTaskCalls(stub func(*types.Task) error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = stub
}

func (fake *FakeStorage) UpdateTaskArgsForCall(i int) *types.Task {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	argsForCall := fake.updateTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) UpdateTaskReturns(result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	fake.updateTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) UpdateTaskReturnsOnCall(i int, result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	if fake.updateTaskReturnsOnCall == nil {
		fake.updateTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMessageToConversationMutex.RLock()
	defer fake.addMessageToConversationMutex.RUnlock()
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	fake.cleanupOldConversationsMutex.RLock()
	defer fake.cleanupOldConversationsMutex.RUnlock()
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.getContextsMutex.RLock()
	defer fake.getContextsMutex.RUnlock()
	fake.getContextsWithTasksMutex.RLock()
	defer fake.getContextsWithTasksMutex.RUnlock()
	fake.getConversationHistoryMutex.RLock()
	defer fake.getConversationHistoryMutex.RUnlock()
	fake.getStatsMutex.RLock()
	defer fake.getStatsMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	fake.storeTaskMutex.RLock()
	defer fake.storeTaskMutex.RUnlock()
	fake.trimConversationHistoryMutex.RLock()
	defer fake.trimConversationHistoryMutex.RUnlock()
	fake.updateConversationHistoryMutex.RLock()
	defer fake.updateConversationHistoryMutex.RUnlock()
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.Storage = new(FakeStorage)
