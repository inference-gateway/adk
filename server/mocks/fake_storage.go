// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/inference-gateway/adk/server"
	"github.com/inference-gateway/adk/types"
)

type FakeStorage struct {
	CleanupCompletedTasksStub        func() int
	cleanupCompletedTasksMutex       sync.RWMutex
	cleanupCompletedTasksArgsForCall []struct {
	}
	cleanupCompletedTasksReturns struct {
		result1 int
	}
	cleanupCompletedTasksReturnsOnCall map[int]struct {
		result1 int
	}
	CleanupTasksWithRetentionStub        func(int, int) int
	cleanupTasksWithRetentionMutex       sync.RWMutex
	cleanupTasksWithRetentionArgsForCall []struct {
		arg1 int
		arg2 int
	}
	cleanupTasksWithRetentionReturns struct {
		result1 int
	}
	cleanupTasksWithRetentionReturnsOnCall map[int]struct {
		result1 int
	}
	ClearQueueStub        func() error
	clearQueueMutex       sync.RWMutex
	clearQueueArgsForCall []struct {
	}
	clearQueueReturns struct {
		result1 error
	}
	clearQueueReturnsOnCall map[int]struct {
		result1 error
	}
	CreateActiveTaskStub        func(*types.Task) error
	createActiveTaskMutex       sync.RWMutex
	createActiveTaskArgsForCall []struct {
		arg1 *types.Task
	}
	createActiveTaskReturns struct {
		result1 error
	}
	createActiveTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteContextStub        func(string) error
	deleteContextMutex       sync.RWMutex
	deleteContextArgsForCall []struct {
		arg1 string
	}
	deleteContextReturns struct {
		result1 error
	}
	deleteContextReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteContextAndTasksStub        func(string) error
	deleteContextAndTasksMutex       sync.RWMutex
	deleteContextAndTasksArgsForCall []struct {
		arg1 string
	}
	deleteContextAndTasksReturns struct {
		result1 error
	}
	deleteContextAndTasksReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DequeueTaskStub        func(context.Context) (*server.QueuedTask, error)
	dequeueTaskMutex       sync.RWMutex
	dequeueTaskArgsForCall []struct {
		arg1 context.Context
	}
	dequeueTaskReturns struct {
		result1 *server.QueuedTask
		result2 error
	}
	dequeueTaskReturnsOnCall map[int]struct {
		result1 *server.QueuedTask
		result2 error
	}
	EnqueueTaskStub        func(*types.Task, interface{}) error
	enqueueTaskMutex       sync.RWMutex
	enqueueTaskArgsForCall []struct {
		arg1 *types.Task
		arg2 interface{}
	}
	enqueueTaskReturns struct {
		result1 error
	}
	enqueueTaskReturnsOnCall map[int]struct {
		result1 error
	}
	GetActiveTaskStub        func(string) (*types.Task, error)
	getActiveTaskMutex       sync.RWMutex
	getActiveTaskArgsForCall []struct {
		arg1 string
	}
	getActiveTaskReturns struct {
		result1 *types.Task
		result2 error
	}
	getActiveTaskReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 error
	}
	GetContextsStub        func() []string
	getContextsMutex       sync.RWMutex
	getContextsArgsForCall []struct {
	}
	getContextsReturns struct {
		result1 []string
	}
	getContextsReturnsOnCall map[int]struct {
		result1 []string
	}
	GetContextsWithTasksStub        func() []string
	getContextsWithTasksMutex       sync.RWMutex
	getContextsWithTasksArgsForCall []struct {
	}
	getContextsWithTasksReturns struct {
		result1 []string
	}
	getContextsWithTasksReturnsOnCall map[int]struct {
		result1 []string
	}
	GetQueueLengthStub        func() int
	getQueueLengthMutex       sync.RWMutex
	getQueueLengthArgsForCall []struct {
	}
	getQueueLengthReturns struct {
		result1 int
	}
	getQueueLengthReturnsOnCall map[int]struct {
		result1 int
	}
	GetStatsStub        func() server.StorageStats
	getStatsMutex       sync.RWMutex
	getStatsArgsForCall []struct {
	}
	getStatsReturns struct {
		result1 server.StorageStats
	}
	getStatsReturnsOnCall map[int]struct {
		result1 server.StorageStats
	}
	GetTaskStub        func(string) (*types.Task, bool)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 string
	}
	getTaskReturns struct {
		result1 *types.Task
		result2 bool
	}
	getTaskReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 bool
	}
	GetTaskByContextAndIDStub        func(string, string) (*types.Task, bool)
	getTaskByContextAndIDMutex       sync.RWMutex
	getTaskByContextAndIDArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getTaskByContextAndIDReturns struct {
		result1 *types.Task
		result2 bool
	}
	getTaskByContextAndIDReturnsOnCall map[int]struct {
		result1 *types.Task
		result2 bool
	}
	ListTasksStub        func(server.TaskFilter) ([]*types.Task, error)
	listTasksMutex       sync.RWMutex
	listTasksArgsForCall []struct {
		arg1 server.TaskFilter
	}
	listTasksReturns struct {
		result1 []*types.Task
		result2 error
	}
	listTasksReturnsOnCall map[int]struct {
		result1 []*types.Task
		result2 error
	}
	ListTasksByContextStub        func(string, server.TaskFilter) ([]*types.Task, error)
	listTasksByContextMutex       sync.RWMutex
	listTasksByContextArgsForCall []struct {
		arg1 string
		arg2 server.TaskFilter
	}
	listTasksByContextReturns struct {
		result1 []*types.Task
		result2 error
	}
	listTasksByContextReturnsOnCall map[int]struct {
		result1 []*types.Task
		result2 error
	}
	StoreDeadLetterTaskStub        func(*types.Task) error
	storeDeadLetterTaskMutex       sync.RWMutex
	storeDeadLetterTaskArgsForCall []struct {
		arg1 *types.Task
	}
	storeDeadLetterTaskReturns struct {
		result1 error
	}
	storeDeadLetterTaskReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateActiveTaskStub        func(*types.Task) error
	updateActiveTaskMutex       sync.RWMutex
	updateActiveTaskArgsForCall []struct {
		arg1 *types.Task
	}
	updateActiveTaskReturns struct {
		result1 error
	}
	updateActiveTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) CleanupCompletedTasks() int {
	fake.cleanupCompletedTasksMutex.Lock()
	ret, specificReturn := fake.cleanupCompletedTasksReturnsOnCall[len(fake.cleanupCompletedTasksArgsForCall)]
	fake.cleanupCompletedTasksArgsForCall = append(fake.cleanupCompletedTasksArgsForCall, struct {
	}{})
	stub := fake.CleanupCompletedTasksStub
	fakeReturns := fake.cleanupCompletedTasksReturns
	fake.recordInvocation("CleanupCompletedTasks", []interface{}{})
	fake.cleanupCompletedTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) CleanupCompletedTasksCallCount() int {
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	return len(fake.cleanupCompletedTasksArgsForCall)
}

func (fake *FakeStorage) CleanupCompletedTasksCalls(stub func() int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = stub
}

func (fake *FakeStorage) CleanupCompletedTasksReturns(result1 int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = nil
	fake.cleanupCompletedTasksReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupCompletedTasksReturnsOnCall(i int, result1 int) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = nil
	if fake.cleanupCompletedTasksReturnsOnCall == nil {
		fake.cleanupCompletedTasksReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cleanupCompletedTasksReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupTasksWithRetention(arg1 int, arg2 int) int {
	fake.cleanupTasksWithRetentionMutex.Lock()
	ret, specificReturn := fake.cleanupTasksWithRetentionReturnsOnCall[len(fake.cleanupTasksWithRetentionArgsForCall)]
	fake.cleanupTasksWithRetentionArgsForCall = append(fake.cleanupTasksWithRetentionArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.CleanupTasksWithRetentionStub
	fakeReturns := fake.cleanupTasksWithRetentionReturns
	fake.recordInvocation("CleanupTasksWithRetention", []interface{}{arg1, arg2})
	fake.cleanupTasksWithRetentionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) CleanupTasksWithRetentionCallCount() int {
	fake.cleanupTasksWithRetentionMutex.RLock()
	defer fake.cleanupTasksWithRetentionMutex.RUnlock()
	return len(fake.cleanupTasksWithRetentionArgsForCall)
}

func (fake *FakeStorage) CleanupTasksWithRetentionCalls(stub func(int, int) int) {
	fake.cleanupTasksWithRetentionMutex.Lock()
	defer fake.cleanupTasksWithRetentionMutex.Unlock()
	fake.CleanupTasksWithRetentionStub = stub
}

func (fake *FakeStorage) CleanupTasksWithRetentionArgsForCall(i int) (int, int) {
	fake.cleanupTasksWithRetentionMutex.RLock()
	defer fake.cleanupTasksWithRetentionMutex.RUnlock()
	argsForCall := fake.cleanupTasksWithRetentionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) CleanupTasksWithRetentionReturns(result1 int) {
	fake.cleanupTasksWithRetentionMutex.Lock()
	defer fake.cleanupTasksWithRetentionMutex.Unlock()
	fake.CleanupTasksWithRetentionStub = nil
	fake.cleanupTasksWithRetentionReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) CleanupTasksWithRetentionReturnsOnCall(i int, result1 int) {
	fake.cleanupTasksWithRetentionMutex.Lock()
	defer fake.cleanupTasksWithRetentionMutex.Unlock()
	fake.CleanupTasksWithRetentionStub = nil
	if fake.cleanupTasksWithRetentionReturnsOnCall == nil {
		fake.cleanupTasksWithRetentionReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cleanupTasksWithRetentionReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) ClearQueue() error {
	fake.clearQueueMutex.Lock()
	ret, specificReturn := fake.clearQueueReturnsOnCall[len(fake.clearQueueArgsForCall)]
	fake.clearQueueArgsForCall = append(fake.clearQueueArgsForCall, struct {
	}{})
	stub := fake.ClearQueueStub
	fakeReturns := fake.clearQueueReturns
	fake.recordInvocation("ClearQueue", []interface{}{})
	fake.clearQueueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) ClearQueueCallCount() int {
	fake.clearQueueMutex.RLock()
	defer fake.clearQueueMutex.RUnlock()
	return len(fake.clearQueueArgsForCall)
}

func (fake *FakeStorage) ClearQueueCalls(stub func() error) {
	fake.clearQueueMutex.Lock()
	defer fake.clearQueueMutex.Unlock()
	fake.ClearQueueStub = stub
}

func (fake *FakeStorage) ClearQueueReturns(result1 error) {
	fake.clearQueueMutex.Lock()
	defer fake.clearQueueMutex.Unlock()
	fake.ClearQueueStub = nil
	fake.clearQueueReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) ClearQueueReturnsOnCall(i int, result1 error) {
	fake.clearQueueMutex.Lock()
	defer fake.clearQueueMutex.Unlock()
	fake.ClearQueueStub = nil
	if fake.clearQueueReturnsOnCall == nil {
		fake.clearQueueReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearQueueReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) CreateActiveTask(arg1 *types.Task) error {
	fake.createActiveTaskMutex.Lock()
	ret, specificReturn := fake.createActiveTaskReturnsOnCall[len(fake.createActiveTaskArgsForCall)]
	fake.createActiveTaskArgsForCall = append(fake.createActiveTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.CreateActiveTaskStub
	fakeReturns := fake.createActiveTaskReturns
	fake.recordInvocation("CreateActiveTask", []interface{}{arg1})
	fake.createActiveTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) CreateActiveTaskCallCount() int {
	fake.createActiveTaskMutex.RLock()
	defer fake.createActiveTaskMutex.RUnlock()
	return len(fake.createActiveTaskArgsForCall)
}

func (fake *FakeStorage) CreateActiveTaskCalls(stub func(*types.Task) error) {
	fake.createActiveTaskMutex.Lock()
	defer fake.createActiveTaskMutex.Unlock()
	fake.CreateActiveTaskStub = stub
}

func (fake *FakeStorage) CreateActiveTaskArgsForCall(i int) *types.Task {
	fake.createActiveTaskMutex.RLock()
	defer fake.createActiveTaskMutex.RUnlock()
	argsForCall := fake.createActiveTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) CreateActiveTaskReturns(result1 error) {
	fake.createActiveTaskMutex.Lock()
	defer fake.createActiveTaskMutex.Unlock()
	fake.CreateActiveTaskStub = nil
	fake.createActiveTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) CreateActiveTaskReturnsOnCall(i int, result1 error) {
	fake.createActiveTaskMutex.Lock()
	defer fake.createActiveTaskMutex.Unlock()
	fake.CreateActiveTaskStub = nil
	if fake.createActiveTaskReturnsOnCall == nil {
		fake.createActiveTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createActiveTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContext(arg1 string) error {
	fake.deleteContextMutex.Lock()
	ret, specificReturn := fake.deleteContextReturnsOnCall[len(fake.deleteContextArgsForCall)]
	fake.deleteContextArgsForCall = append(fake.deleteContextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteContextStub
	fakeReturns := fake.deleteContextReturns
	fake.recordInvocation("DeleteContext", []interface{}{arg1})
	fake.deleteContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteContextCallCount() int {
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	return len(fake.deleteContextArgsForCall)
}

func (fake *FakeStorage) DeleteContextCalls(stub func(string) error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = stub
}

func (fake *FakeStorage) DeleteContextArgsForCall(i int) string {
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	argsForCall := fake.deleteContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteContextReturns(result1 error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = nil
	fake.deleteContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextReturnsOnCall(i int, result1 error) {
	fake.deleteContextMutex.Lock()
	defer fake.deleteContextMutex.Unlock()
	fake.DeleteContextStub = nil
	if fake.deleteContextReturnsOnCall == nil {
		fake.deleteContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextAndTasks(arg1 string) error {
	fake.deleteContextAndTasksMutex.Lock()
	ret, specificReturn := fake.deleteContextAndTasksReturnsOnCall[len(fake.deleteContextAndTasksArgsForCall)]
	fake.deleteContextAndTasksArgsForCall = append(fake.deleteContextAndTasksArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteContextAndTasksStub
	fakeReturns := fake.deleteContextAndTasksReturns
	fake.recordInvocation("DeleteContextAndTasks", []interface{}{arg1})
	fake.deleteContextAndTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteContextAndTasksCallCount() int {
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	return len(fake.deleteContextAndTasksArgsForCall)
}

func (fake *FakeStorage) DeleteContextAndTasksCalls(stub func(string) error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = stub
}

func (fake *FakeStorage) DeleteContextAndTasksArgsForCall(i int) string {
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	argsForCall := fake.deleteContextAndTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteContextAndTasksReturns(result1 error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = nil
	fake.deleteContextAndTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteContextAndTasksReturnsOnCall(i int, result1 error) {
	fake.deleteContextAndTasksMutex.Lock()
	defer fake.deleteContextAndTasksMutex.Unlock()
	fake.DeleteContextAndTasksStub = nil
	if fake.deleteContextAndTasksReturnsOnCall == nil {
		fake.deleteContextAndTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContextAndTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteTask(arg1 string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteTaskStub
	fakeReturns := fake.deleteTaskReturns
	fake.recordInvocation("DeleteTask", []interface{}{arg1})
	fake.deleteTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeStorage) DeleteTaskCalls(stub func(string) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeStorage) DeleteTaskArgsForCall(i int) string {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DequeueTask(arg1 context.Context) (*server.QueuedTask, error) {
	fake.dequeueTaskMutex.Lock()
	ret, specificReturn := fake.dequeueTaskReturnsOnCall[len(fake.dequeueTaskArgsForCall)]
	fake.dequeueTaskArgsForCall = append(fake.dequeueTaskArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DequeueTaskStub
	fakeReturns := fake.dequeueTaskReturns
	fake.recordInvocation("DequeueTask", []interface{}{arg1})
	fake.dequeueTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) DequeueTaskCallCount() int {
	fake.dequeueTaskMutex.RLock()
	defer fake.dequeueTaskMutex.RUnlock()
	return len(fake.dequeueTaskArgsForCall)
}

func (fake *FakeStorage) DequeueTaskCalls(stub func(context.Context) (*server.QueuedTask, error)) {
	fake.dequeueTaskMutex.Lock()
	defer fake.dequeueTaskMutex.Unlock()
	fake.DequeueTaskStub = stub
}

func (fake *FakeStorage) DequeueTaskArgsForCall(i int) context.Context {
	fake.dequeueTaskMutex.RLock()
	defer fake.dequeueTaskMutex.RUnlock()
	argsForCall := fake.dequeueTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) DequeueTaskReturns(result1 *server.QueuedTask, result2 error) {
	fake.dequeueTaskMutex.Lock()
	defer fake.dequeueTaskMutex.Unlock()
	fake.DequeueTaskStub = nil
	fake.dequeueTaskReturns = struct {
		result1 *server.QueuedTask
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) DequeueTaskReturnsOnCall(i int, result1 *server.QueuedTask, result2 error) {
	fake.dequeueTaskMutex.Lock()
	defer fake.dequeueTaskMutex.Unlock()
	fake.DequeueTaskStub = nil
	if fake.dequeueTaskReturnsOnCall == nil {
		fake.dequeueTaskReturnsOnCall = make(map[int]struct {
			result1 *server.QueuedTask
			result2 error
		})
	}
	fake.dequeueTaskReturnsOnCall[i] = struct {
		result1 *server.QueuedTask
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) EnqueueTask(arg1 *types.Task, arg2 interface{}) error {
	fake.enqueueTaskMutex.Lock()
	ret, specificReturn := fake.enqueueTaskReturnsOnCall[len(fake.enqueueTaskArgsForCall)]
	fake.enqueueTaskArgsForCall = append(fake.enqueueTaskArgsForCall, struct {
		arg1 *types.Task
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.EnqueueTaskStub
	fakeReturns := fake.enqueueTaskReturns
	fake.recordInvocation("EnqueueTask", []interface{}{arg1, arg2})
	fake.enqueueTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) EnqueueTaskCallCount() int {
	fake.enqueueTaskMutex.RLock()
	defer fake.enqueueTaskMutex.RUnlock()
	return len(fake.enqueueTaskArgsForCall)
}

func (fake *FakeStorage) EnqueueTaskCalls(stub func(*types.Task, interface{}) error) {
	fake.enqueueTaskMutex.Lock()
	defer fake.enqueueTaskMutex.Unlock()
	fake.EnqueueTaskStub = stub
}

func (fake *FakeStorage) EnqueueTaskArgsForCall(i int) (*types.Task, interface{}) {
	fake.enqueueTaskMutex.RLock()
	defer fake.enqueueTaskMutex.RUnlock()
	argsForCall := fake.enqueueTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) EnqueueTaskReturns(result1 error) {
	fake.enqueueTaskMutex.Lock()
	defer fake.enqueueTaskMutex.Unlock()
	fake.EnqueueTaskStub = nil
	fake.enqueueTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) EnqueueTaskReturnsOnCall(i int, result1 error) {
	fake.enqueueTaskMutex.Lock()
	defer fake.enqueueTaskMutex.Unlock()
	fake.EnqueueTaskStub = nil
	if fake.enqueueTaskReturnsOnCall == nil {
		fake.enqueueTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enqueueTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) GetActiveTask(arg1 string) (*types.Task, error) {
	fake.getActiveTaskMutex.Lock()
	ret, specificReturn := fake.getActiveTaskReturnsOnCall[len(fake.getActiveTaskArgsForCall)]
	fake.getActiveTaskArgsForCall = append(fake.getActiveTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetActiveTaskStub
	fakeReturns := fake.getActiveTaskReturns
	fake.recordInvocation("GetActiveTask", []interface{}{arg1})
	fake.getActiveTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetActiveTaskCallCount() int {
	fake.getActiveTaskMutex.RLock()
	defer fake.getActiveTaskMutex.RUnlock()
	return len(fake.getActiveTaskArgsForCall)
}

func (fake *FakeStorage) GetActiveTaskCalls(stub func(string) (*types.Task, error)) {
	fake.getActiveTaskMutex.Lock()
	defer fake.getActiveTaskMutex.Unlock()
	fake.GetActiveTaskStub = stub
}

func (fake *FakeStorage) GetActiveTaskArgsForCall(i int) string {
	fake.getActiveTaskMutex.RLock()
	defer fake.getActiveTaskMutex.RUnlock()
	argsForCall := fake.getActiveTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) GetActiveTaskReturns(result1 *types.Task, result2 error) {
	fake.getActiveTaskMutex.Lock()
	defer fake.getActiveTaskMutex.Unlock()
	fake.GetActiveTaskStub = nil
	fake.getActiveTaskReturns = struct {
		result1 *types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetActiveTaskReturnsOnCall(i int, result1 *types.Task, result2 error) {
	fake.getActiveTaskMutex.Lock()
	defer fake.getActiveTaskMutex.Unlock()
	fake.GetActiveTaskStub = nil
	if fake.getActiveTaskReturnsOnCall == nil {
		fake.getActiveTaskReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 error
		})
	}
	fake.getActiveTaskReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetContexts() []string {
	fake.getContextsMutex.Lock()
	ret, specificReturn := fake.getContextsReturnsOnCall[len(fake.getContextsArgsForCall)]
	fake.getContextsArgsForCall = append(fake.getContextsArgsForCall, struct {
	}{})
	stub := fake.GetContextsStub
	fakeReturns := fake.getContextsReturns
	fake.recordInvocation("GetContexts", []interface{}{})
	fake.getContextsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetContextsCallCount() int {
	fake.getContextsMutex.RLock()
	defer fake.getContextsMutex.RUnlock()
	return len(fake.getContextsArgsForCall)
}

func (fake *FakeStorage) GetContextsCalls(stub func() []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = stub
}

func (fake *FakeStorage) GetContextsReturns(result1 []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = nil
	fake.getContextsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsReturnsOnCall(i int, result1 []string) {
	fake.getContextsMutex.Lock()
	defer fake.getContextsMutex.Unlock()
	fake.GetContextsStub = nil
	if fake.getContextsReturnsOnCall == nil {
		fake.getContextsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getContextsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsWithTasks() []string {
	fake.getContextsWithTasksMutex.Lock()
	ret, specificReturn := fake.getContextsWithTasksReturnsOnCall[len(fake.getContextsWithTasksArgsForCall)]
	fake.getContextsWithTasksArgsForCall = append(fake.getContextsWithTasksArgsForCall, struct {
	}{})
	stub := fake.GetContextsWithTasksStub
	fakeReturns := fake.getContextsWithTasksReturns
	fake.recordInvocation("GetContextsWithTasks", []interface{}{})
	fake.getContextsWithTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetContextsWithTasksCallCount() int {
	fake.getContextsWithTasksMutex.RLock()
	defer fake.getContextsWithTasksMutex.RUnlock()
	return len(fake.getContextsWithTasksArgsForCall)
}

func (fake *FakeStorage) GetContextsWithTasksCalls(stub func() []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = stub
}

func (fake *FakeStorage) GetContextsWithTasksReturns(result1 []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = nil
	fake.getContextsWithTasksReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetContextsWithTasksReturnsOnCall(i int, result1 []string) {
	fake.getContextsWithTasksMutex.Lock()
	defer fake.getContextsWithTasksMutex.Unlock()
	fake.GetContextsWithTasksStub = nil
	if fake.getContextsWithTasksReturnsOnCall == nil {
		fake.getContextsWithTasksReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getContextsWithTasksReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeStorage) GetQueueLength() int {
	fake.getQueueLengthMutex.Lock()
	ret, specificReturn := fake.getQueueLengthReturnsOnCall[len(fake.getQueueLengthArgsForCall)]
	fake.getQueueLengthArgsForCall = append(fake.getQueueLengthArgsForCall, struct {
	}{})
	stub := fake.GetQueueLengthStub
	fakeReturns := fake.getQueueLengthReturns
	fake.recordInvocation("GetQueueLength", []interface{}{})
	fake.getQueueLengthMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetQueueLengthCallCount() int {
	fake.getQueueLengthMutex.RLock()
	defer fake.getQueueLengthMutex.RUnlock()
	return len(fake.getQueueLengthArgsForCall)
}

func (fake *FakeStorage) GetQueueLengthCalls(stub func() int) {
	fake.getQueueLengthMutex.Lock()
	defer fake.getQueueLengthMutex.Unlock()
	fake.GetQueueLengthStub = stub
}

func (fake *FakeStorage) GetQueueLengthReturns(result1 int) {
	fake.getQueueLengthMutex.Lock()
	defer fake.getQueueLengthMutex.Unlock()
	fake.GetQueueLengthStub = nil
	fake.getQueueLengthReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) GetQueueLengthReturnsOnCall(i int, result1 int) {
	fake.getQueueLengthMutex.Lock()
	defer fake.getQueueLengthMutex.Unlock()
	fake.GetQueueLengthStub = nil
	if fake.getQueueLengthReturnsOnCall == nil {
		fake.getQueueLengthReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getQueueLengthReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStorage) GetStats() server.StorageStats {
	fake.getStatsMutex.Lock()
	ret, specificReturn := fake.getStatsReturnsOnCall[len(fake.getStatsArgsForCall)]
	fake.getStatsArgsForCall = append(fake.getStatsArgsForCall, struct {
	}{})
	stub := fake.GetStatsStub
	fakeReturns := fake.getStatsReturns
	fake.recordInvocation("GetStats", []interface{}{})
	fake.getStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) GetStatsCallCount() int {
	fake.getStatsMutex.RLock()
	defer fake.getStatsMutex.RUnlock()
	return len(fake.getStatsArgsForCall)
}

func (fake *FakeStorage) GetStatsCalls(stub func() server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = stub
}

func (fake *FakeStorage) GetStatsReturns(result1 server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = nil
	fake.getStatsReturns = struct {
		result1 server.StorageStats
	}{result1}
}

func (fake *FakeStorage) GetStatsReturnsOnCall(i int, result1 server.StorageStats) {
	fake.getStatsMutex.Lock()
	defer fake.getStatsMutex.Unlock()
	fake.GetStatsStub = nil
	if fake.getStatsReturnsOnCall == nil {
		fake.getStatsReturnsOnCall = make(map[int]struct {
			result1 server.StorageStats
		})
	}
	fake.getStatsReturnsOnCall[i] = struct {
		result1 server.StorageStats
	}{result1}
}

func (fake *FakeStorage) GetTask(arg1 string) (*types.Task, bool) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeStorage) GetTaskCalls(stub func(string) (*types.Task, bool)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeStorage) GetTaskArgsForCall(i int) string {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) GetTaskReturns(result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskReturnsOnCall(i int, result1 *types.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 bool
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskByContextAndID(arg1 string, arg2 string) (*types.Task, bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	ret, specificReturn := fake.getTaskByContextAndIDReturnsOnCall[len(fake.getTaskByContextAndIDArgsForCall)]
	fake.getTaskByContextAndIDArgsForCall = append(fake.getTaskByContextAndIDArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTaskByContextAndIDStub
	fakeReturns := fake.getTaskByContextAndIDReturns
	fake.recordInvocation("GetTaskByContextAndID", []interface{}{arg1, arg2})
	fake.getTaskByContextAndIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetTaskByContextAndIDCallCount() int {
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	return len(fake.getTaskByContextAndIDArgsForCall)
}

func (fake *FakeStorage) GetTaskByContextAndIDCalls(stub func(string, string) (*types.Task, bool)) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = stub
}

func (fake *FakeStorage) GetTaskByContextAndIDArgsForCall(i int) (string, string) {
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	argsForCall := fake.getTaskByContextAndIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetTaskByContextAndIDReturns(result1 *types.Task, result2 bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = nil
	fake.getTaskByContextAndIDReturns = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) GetTaskByContextAndIDReturnsOnCall(i int, result1 *types.Task, result2 bool) {
	fake.getTaskByContextAndIDMutex.Lock()
	defer fake.getTaskByContextAndIDMutex.Unlock()
	fake.GetTaskByContextAndIDStub = nil
	if fake.getTaskByContextAndIDReturnsOnCall == nil {
		fake.getTaskByContextAndIDReturnsOnCall = make(map[int]struct {
			result1 *types.Task
			result2 bool
		})
	}
	fake.getTaskByContextAndIDReturnsOnCall[i] = struct {
		result1 *types.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeStorage) ListTasks(arg1 server.TaskFilter) ([]*types.Task, error) {
	fake.listTasksMutex.Lock()
	ret, specificReturn := fake.listTasksReturnsOnCall[len(fake.listTasksArgsForCall)]
	fake.listTasksArgsForCall = append(fake.listTasksArgsForCall, struct {
		arg1 server.TaskFilter
	}{arg1})
	stub := fake.ListTasksStub
	fakeReturns := fake.listTasksReturns
	fake.recordInvocation("ListTasks", []interface{}{arg1})
	fake.listTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ListTasksCallCount() int {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	return len(fake.listTasksArgsForCall)
}

func (fake *FakeStorage) ListTasksCalls(stub func(server.TaskFilter) ([]*types.Task, error)) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = stub
}

func (fake *FakeStorage) ListTasksArgsForCall(i int) server.TaskFilter {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	argsForCall := fake.listTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) ListTasksReturns(result1 []*types.Task, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	fake.listTasksReturns = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksReturnsOnCall(i int, result1 []*types.Task, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	if fake.listTasksReturnsOnCall == nil {
		fake.listTasksReturnsOnCall = make(map[int]struct {
			result1 []*types.Task
			result2 error
		})
	}
	fake.listTasksReturnsOnCall[i] = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksByContext(arg1 string, arg2 server.TaskFilter) ([]*types.Task, error) {
	fake.listTasksByContextMutex.Lock()
	ret, specificReturn := fake.listTasksByContextReturnsOnCall[len(fake.listTasksByContextArgsForCall)]
	fake.listTasksByContextArgsForCall = append(fake.listTasksByContextArgsForCall, struct {
		arg1 string
		arg2 server.TaskFilter
	}{arg1, arg2})
	stub := fake.ListTasksByContextStub
	fakeReturns := fake.listTasksByContextReturns
	fake.recordInvocation("ListTasksByContext", []interface{}{arg1, arg2})
	fake.listTasksByContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ListTasksByContextCallCount() int {
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	return len(fake.listTasksByContextArgsForCall)
}

func (fake *FakeStorage) ListTasksByContextCalls(stub func(string, server.TaskFilter) ([]*types.Task, error)) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = stub
}

func (fake *FakeStorage) ListTasksByContextArgsForCall(i int) (string, server.TaskFilter) {
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	argsForCall := fake.listTasksByContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) ListTasksByContextReturns(result1 []*types.Task, result2 error) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = nil
	fake.listTasksByContextReturns = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListTasksByContextReturnsOnCall(i int, result1 []*types.Task, result2 error) {
	fake.listTasksByContextMutex.Lock()
	defer fake.listTasksByContextMutex.Unlock()
	fake.ListTasksByContextStub = nil
	if fake.listTasksByContextReturnsOnCall == nil {
		fake.listTasksByContextReturnsOnCall = make(map[int]struct {
			result1 []*types.Task
			result2 error
		})
	}
	fake.listTasksByContextReturnsOnCall[i] = struct {
		result1 []*types.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) StoreDeadLetterTask(arg1 *types.Task) error {
	fake.storeDeadLetterTaskMutex.Lock()
	ret, specificReturn := fake.storeDeadLetterTaskReturnsOnCall[len(fake.storeDeadLetterTaskArgsForCall)]
	fake.storeDeadLetterTaskArgsForCall = append(fake.storeDeadLetterTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.StoreDeadLetterTaskStub
	fakeReturns := fake.storeDeadLetterTaskReturns
	fake.recordInvocation("StoreDeadLetterTask", []interface{}{arg1})
	fake.storeDeadLetterTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) StoreDeadLetterTaskCallCount() int {
	fake.storeDeadLetterTaskMutex.RLock()
	defer fake.storeDeadLetterTaskMutex.RUnlock()
	return len(fake.storeDeadLetterTaskArgsForCall)
}

func (fake *FakeStorage) StoreDeadLetterTaskCalls(stub func(*types.Task) error) {
	fake.storeDeadLetterTaskMutex.Lock()
	defer fake.storeDeadLetterTaskMutex.Unlock()
	fake.StoreDeadLetterTaskStub = stub
}

func (fake *FakeStorage) StoreDeadLetterTaskArgsForCall(i int) *types.Task {
	fake.storeDeadLetterTaskMutex.RLock()
	defer fake.storeDeadLetterTaskMutex.RUnlock()
	argsForCall := fake.storeDeadLetterTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) StoreDeadLetterTaskReturns(result1 error) {
	fake.storeDeadLetterTaskMutex.Lock()
	defer fake.storeDeadLetterTaskMutex.Unlock()
	fake.StoreDeadLetterTaskStub = nil
	fake.storeDeadLetterTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) StoreDeadLetterTaskReturnsOnCall(i int, result1 error) {
	fake.storeDeadLetterTaskMutex.Lock()
	defer fake.storeDeadLetterTaskMutex.Unlock()
	fake.StoreDeadLetterTaskStub = nil
	if fake.storeDeadLetterTaskReturnsOnCall == nil {
		fake.storeDeadLetterTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeDeadLetterTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) UpdateActiveTask(arg1 *types.Task) error {
	fake.updateActiveTaskMutex.Lock()
	ret, specificReturn := fake.updateActiveTaskReturnsOnCall[len(fake.updateActiveTaskArgsForCall)]
	fake.updateActiveTaskArgsForCall = append(fake.updateActiveTaskArgsForCall, struct {
		arg1 *types.Task
	}{arg1})
	stub := fake.UpdateActiveTaskStub
	fakeReturns := fake.updateActiveTaskReturns
	fake.recordInvocation("UpdateActiveTask", []interface{}{arg1})
	fake.updateActiveTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) UpdateActiveTaskCallCount() int {
	fake.updateActiveTaskMutex.RLock()
	defer fake.updateActiveTaskMutex.RUnlock()
	return len(fake.updateActiveTaskArgsForCall)
}

func (fake *FakeStorage) UpdateActiveTaskCalls(stub func(*types.Task) error) {
	fake.updateActiveTaskMutex.Lock()
	defer fake.updateActiveTaskMutex.Unlock()
	fake.UpdateActiveTaskStub = stub
}

func (fake *FakeStorage) UpdateActiveTaskArgsForCall(i int) *types.Task {
	fake.updateActiveTaskMutex.RLock()
	defer fake.updateActiveTaskMutex.RUnlock()
	argsForCall := fake.updateActiveTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) UpdateActiveTaskReturns(result1 error) {
	fake.updateActiveTaskMutex.Lock()
	defer fake.updateActiveTaskMutex.Unlock()
	fake.UpdateActiveTaskStub = nil
	fake.updateActiveTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) UpdateActiveTaskReturnsOnCall(i int, result1 error) {
	fake.updateActiveTaskMutex.Lock()
	defer fake.updateActiveTaskMutex.Unlock()
	fake.UpdateActiveTaskStub = nil
	if fake.updateActiveTaskReturnsOnCall == nil {
		fake.updateActiveTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateActiveTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	fake.cleanupTasksWithRetentionMutex.RLock()
	defer fake.cleanupTasksWithRetentionMutex.RUnlock()
	fake.clearQueueMutex.RLock()
	defer fake.clearQueueMutex.RUnlock()
	fake.createActiveTaskMutex.RLock()
	defer fake.createActiveTaskMutex.RUnlock()
	fake.deleteContextMutex.RLock()
	defer fake.deleteContextMutex.RUnlock()
	fake.deleteContextAndTasksMutex.RLock()
	defer fake.deleteContextAndTasksMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.dequeueTaskMutex.RLock()
	defer fake.dequeueTaskMutex.RUnlock()
	fake.enqueueTaskMutex.RLock()
	defer fake.enqueueTaskMutex.RUnlock()
	fake.getActiveTaskMutex.RLock()
	defer fake.getActiveTaskMutex.RUnlock()
	fake.getContextsMutex.RLock()
	defer fake.getContextsMutex.RUnlock()
	fake.getContextsWithTasksMutex.RLock()
	defer fake.getContextsWithTasksMutex.RUnlock()
	fake.getQueueLengthMutex.RLock()
	defer fake.getQueueLengthMutex.RUnlock()
	fake.getStatsMutex.RLock()
	defer fake.getStatsMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.getTaskByContextAndIDMutex.RLock()
	defer fake.getTaskByContextAndIDMutex.RUnlock()
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	fake.listTasksByContextMutex.RLock()
	defer fake.listTasksByContextMutex.RUnlock()
	fake.storeDeadLetterTaskMutex.RLock()
	defer fake.storeDeadLetterTaskMutex.RUnlock()
	fake.updateActiveTaskMutex.RLock()
	defer fake.updateActiveTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.Storage = new(FakeStorage)
